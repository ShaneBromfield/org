#+Title: practical clojure
#+author: Antoine Romain Dumont
#+STARTUP: indent
#+STARTUP: hidestars odd

* DONE About the Authors.......................................................................................... xiv
* DONE About the Technical Reviewer ............................................................................... xv
* DONE Acknowledgments ........................................................................................... xvi
* DONE Chapter 1: The Clojure Way [3/3] .............................................................................1
*** DONE Clojure’s Philosophy and Special Features ................................................................1
***** DONE A Next-Generation Language................................................................................ 1
The future so why fight it!?
***** DONE Dynamic and Powerful (Yes, It’s a Lisp) .................................................................. 1
ugly for some but excellent for others, clojure is awsome as a lisp language.
***** DONE The Java Platform......................................................................................... 2
The jvm is a real good piece of software. Clojure uses it at its advantages.
*** DONE Functional Programming [8/8] .............................................................................2
***** DONE Purely Functional Programming ............................................................................ 4
Based on pure function:
- only inputs (parameters) and output
- no interaction with the outside
- no state
- more simple to test
- black box
***** DONE Clojure’s Compromise ..................................................................................... 6
Coding purely functional functions is impossible but clojure tends
towards it as much as it can.
As clojure can manipulate java objects, there is no purity (java
objects are by definition stateful) when
manipulating those.
***** DONE Immutability.............................................................................................. 7
Structures are immutable.
When needed to change, a new object is copied but share the common
structure - this shared structure is called persitence.
The old shared structure which is not shared anymore will be silently garbage collected.

Many structures:
- Linked list
- Vectors
- Hash maps
- Sorted maps
- Hash and sorted sets
***** DONE What about Object-Oriented Programming? .................................................................. 9
- Clojure is not object oriented.
    - mutability
    - no facility in code modularization and abstraction -> spaghetti code
    - inheritance is fragile and can be dangerous
    - code bloat -> needs some frameworks to improve the code -> more
      boilerplates and interface not serving the soft...
- Clojure shares the good parts of the OO paradigm
    - modularity
    - polymorphism
    - encapsulation
    - reusability
- Another difference
***** DONE Structure of a clojure program .......................................................................... 10
***** DONE State Management ........................................................................................ 11
stateful objects == new spaghetti code
***** DONE State and Identity ...................................................................................... 12
***** DONE Software Transactional Memory ........................................................................... 13
*** DONE Summary .................................................................................................15
* DONE Chapter 2: The Clojure Environment [7/7] ....................................................................17
*** DONE "Hello World" in Clojure.................................................................................17
REPL: Read Evaluate Print Loop
Launch clojure:
#+BEGIN_SRC sh
tony@dagobah $ clojure
#+END_SRC
*** DONE Clojure Forms [4/4] .....................................................................................18
Any unit of code that can be evaluated to return a value.
4 types of form
***** DONE Literals................................................................................................ 18
Forms that resolve to themselves. ~ constants
***** DONE Symbols................................................................................................. 19
Forms that resolve to a value. ~ local variables
***** DONE Composite Forms......................................................................................... 19
Everything that's wrapped with parenthesis (list) or brackets
(vectors) or braces (map).
Entire programs is lists.
Code is data and data can be code.
***** DONE Special Forms........................................................................................... 19
Special system form that is part of the clojure core.
*** DONE Writing and Running Source Files ........................................................................20
Loading clojure code from the repl through a file:
#+BEGIN_SRC clj
user=> (load-file "./hello-world.clj")
Hello, World!
I'm running Clojure code from a file.
nil
#+END_SRC

From the cli:
#+BEGIN_SRC sh
java –jar clojure-1.0.0.jar ./hello-world.clj
#+END_SRC
*** DONE Vars, Namespaces, and the Environment....................................................................21
Vars are "global variables". Declared with "def".
Beware of the order in which you're declaring variables (difference
between REPL and launching the file).
Do NOT redefine Vars.
*** DONE Symbols and Symbol Resolution [2/2]......................................................................23
***** DONE Symbol Names ........................................................................................... 23
***** DONE Symbol Resolution and Scope ............................................................................ 24
*** DONE Namespaces [3/3] ........................................................................................24
***** DONE Declaring Namespaces.................................................................................... 25
***** DONE Referencing Namespaces.................................................................................. 25
***** DONE Structuring Source Files ............................................................................... 26
*** DONE Summary .................................................................................................26
4 main units called forms: literals, symbols, special forms and
composites.
Vars are some sort of "global variables" with a limited scope, its namespace.
Break into multiple files with for each file a namespace.
Use namespaces and :use them.
* DONE Chapter 3: Controlling Program Flow [6/6] ..................................................................29
CLOSED: [2011-09-13 mar. 21:41]
*** DONE Functions [6/6] .........................................................................................29
Functions are the beginning and the end of clojure.
***** DONE First-Class Functions................................................................................... 29
In clojure, all functions are first-class object, which means
- can be created at any time
- not named but can be bound to symbol(s)
- can be passed to and returned from any functions
- can be stored as values in any data structures
***** DONE Defining Functions with fn ............................................................................. 29
only 2 arguments
#+BEGIN_SRC clj
(fn [x y] (* x y))
#+END_SRC
this function is not named, so we can bind it to a symbol.
#+BEGIN_SRC clj
(def my-mult (fn [x y] (* x y)))
#+END_SRC
A function is not called by a name, it is resolved from the symbol
they are bound to.
***** DONE Defining Functions with defn............................................................................ 31
defn shortcut to define a function and bind it to a symbol and
document it. Use it.
#+BEGIN_SRC clj
(fact (sq 0) => 0)
(fact (sq 5) => 25)

(defn sq
  "squares the provided argument"
  [x]
  (* x x))
#+END_SRC
***** DONE Functions of Multiple Arities........................................................................... 31
We can define multiple implementations of a function depending on the number of arguments.
#+BEGIN_SRC clj
(fact (square-or-multiply) => 0)
(fact (square-or-multiply 5) => 25)
(fact (square-or-multiply 5 6) => 30)

(defn square-or-multiply
  "squares the simple provided argument, multiply the 2 arguments provided"
  ([] 0)
  ([x] (* x x))
  ([x y] (* x y)))
#+BEGIN_SRC

***** DONE Functions with Variable Arguments....................................................................... 32
Arity not fixed.
Use a keyword & to represent this variable arity.
#+BEGIN_SRC clj
(fact (add-arg-count 5) => 5)
(fact (add-arg-count 5 0) => 6)
(fact (add-arg-count 5 0 1 2 3) => 9)

(defn add-arg-count
  "Returns the sum of the first argument and the number additionals arguments"
  [first & more]
  (+ first (count more)))
#+END_SRC

***** DONE Shorthand Function Declaration ......................................................................... 33
Reading macro
- with same argument
#+BEGIN_SRC clj
(fact (sq2 0) => 0)
;.;. The work itself praises the master. -- CPE Bach
(fact (sq2 5) => 25)

(def sq2 #(* % %))
#+BEGIN_SRC
- with different arguments
#+BEGIN_SRC clj
(fact (my-mult2 10 2) => 20)
;.;. This is the future you were hoping for. -- @Vaguery
(fact (my-mult 1 2) => 2)

(def my-mult2 #(* %1 %2))
#+BEGIN_SRCDONE Conditional Expressions..................................................................................34
if statement.
#+BEGIN_SRC clj
(fact (if (= 1 1) "Maths still work!") => "Maths still work!")
(fact (if (= 1 2) "Maths is broken!" "Maths still work!") => "Maths still work!")

(fact (if-not (= 1 1) "Maths is broken!" "Maths still work!") => "Maths still work!")
#+END_SRC

cond statements
#+BEGIN_SRC clj
(defn weather-judge
  "given a temperature in degree centigrade, it will comment on the weather's quality"
  [x]
  (cond
   (<= x 0) "extremely cold!"
   (<= x 10) "cold!"
   (<= x 20) "nice!"
   :else "too hot!")
  )

(fact (weather-judge -10) => "extremely cold!")
(fact (weather-judge 10) => "cold!")
(fact (weather-judge 20) => "nice!")
;.;. Before the reward there must be labor. You plant before you
;.;. harvest. You sow in tears before you reap joy. -- Ransom
(fact (weather-judge 30) => "too hot!")
#+END_SRC

if cond too large, difficult to maintain -> use multimethods instead.
*** DONE Local Bindings ..........................................................................................35
Use let to assign local symbol.
This permits a cleaner and much comprehensive code.

*** DONE Looping and Recursion ...................................................................................36
CLOSED: [2011-09-12 lun. 07:46]
*** DONE Tail Recursion [2/2] ................................................................................... 39
Tail recursive because the base condition only return the result and
no computation is done with this result
Only tail recursive algorithm can be optimized.
***** DONE Clojure's recur
Using recur explicitely exposes that the method is Tail recursived optimized.
CLOSED: [2011-09-12 lun. 14:00]
***** DONE Using loop
CLOSED: [2011-09-12 lun. 18:50]
*** DONE Deliberate Side Effects [2/2] ...........................................................................42
CLOSED: [2011-09-13 mar. 07:28]
***** DONE Using do................................................................................................ 42
Use 'do' to call side effects functions (java functions for example).
CLOSED: [2011-09-13 mar. 07:15]
***** DONE Side Effects in Function Definitions.................................................................... 43
CLOSED: [2011-09-13 mar. 07:27]
*** DONE Functional Programming Techniques [6/6] .................................................................43
CLOSED: [2011-09-13 mar. 13:26]
***** DONE First-Class Functions................................................................................... 43
CLOSED: [2011-09-13 mar. 07:28]
***** DONE Consuming first class functions
Functions can be passed to other functions as arguments.
This makes the reuse simple.
Permits genericity.
CLOSED: [2011-09-13 mar. 07:38]
***** DONE Producing first class functions
CLOSED: [2011-09-13 mar. 07:57]
Functions can be created on the fly by other functions.
***** DONE Closures................................................................................................ 46
CLOSED: [2011-09-13 mar. 08:05]
First class functions that contain values as well as code.
The symbols used in the closure are by essence constants.
the rangechecker example is a closure.
***** DONE Currying and Composing Functions........................................................................ 46
CLOSED: [2011-09-13 mar. 13:23]
Curry-> embed a function into a closure with fewer arguments
******* DONE Using partial to curry functions
CLOSED: [2011-09-13 mar. 13:10]
keyword: partial
******* DONE Using comp to compose functions
CLOSED: [2011-09-13 mar. 13:23]
***** DONE Putting It All Together................................................................................. 48
CLOSED: [2011-09-13 mar. 13:26]
* DONE Chapter 4: Data in Clojure [4/4] ...........................................................................51
CLOSED: [2011-09-16 ven. 07:35]
*** DONE How to Represent and Manipulate Data ....................................................................51
CLOSED: [2011-09-13 mar. 13:31]
***** DONE Nil .................................................................................................... 52
CLOSED: [2011-09-13 mar. 13:31]
*** DONE Primitive Types .........................................................................................52
CLOSED: [2011-09-15 jeu. 07:16]
***** DONE Numbers ................................................................................................ 52
CLOSED: [2011-09-13 mar. 13:35]
- No limit of size for numbers. Managed internally.
- can manage the base 2 to 36
******* DONE Common numeric functions
CLOSED: [2011-09-13 mar. 21:41]
***** DONE Strings ................................................................................................ 57
CLOSED: [2011-09-14 mer. 07:42]
******* DONE Common String functions
CLOSED: [2011-09-14 mer. 07:18]
******* DONE Regular expressions functions
CLOSED: [2011-09-14 mer. 07:42]
***** DONE Boolean................................................................................................. 60
CLOSED: [2011-09-14 mer. 07:44]
***** DONE Characters ............................................................................................. 61
CLOSED: [2011-09-14 mer. 07:45]
Escape a char with \.
\a is the a character.
***** DONE Keywords................................................................................................ 61
CLOSED: [2011-09-14 mer. 18:24]
*** DONE Collections .............................................................................................62
CLOSED: [2011-09-15 jeu. 22:01]
- immutables
- persistent as much as possible. share common history with their ancestor
- proper equality semantics
- easy to use and hassle free
- implements the java.util.Collections for the no mutable part.
- support powerful sequence abstraction (?)
***** DONE Lists .................................................................................................. 63
CLOSED: [2011-09-14 mer. 18:58]
- Linked list
- Ordered sequence of items.
- Use ' or quote to escape the clojure interpretation
***** DONE Vectors................................................................................................. 64
CLOSED: [2011-09-15 jeu. 21:02]
- Ordered sequence of items
- support efficient, nearly constant time access to index
- should be preferred to list because no disadvantages and more efficient
- access to the index like a function call.
***** DONE Maps.................................................................................................... 66
CLOSED: [2011-09-15 jeu. 21:41]
***** DONE Sets ................................................................................................... 71
CLOSED: [2011-09-15 jeu. 22:01]
*** DONE Summary .................................................................................................72
CLOSED: [2011-09-16 ven. 07:35]
* DONE Chapter 5: Sequences [6/6] .................................................................................73
CLOSED: [2011-09-20 mar. 13:30]
*** DONE What Are Sequences?......................................................................................73
CLOSED: [2011-09-16 ven. 13:00]
- Use seq to make a form a sequence.
- Do not modify java collections when you iterate over a view of it
because the java collection are mutable.
***** DONE Sequenceable Types...................................................................................... 75
CLOSED: [2011-09-16 ven. 13:00]
- clojure's persistent collection
- java arrays
- java collections that implements java.lang.Iterable
- string
*** DONE Anatomy of a Sequence....................................................................................75
CLOSED: [2011-09-16 ven. 18:41]
*** DONE Constructing Sequences...................................................................................76
CLOSED: [2011-09-16 ven. 18:41]
*** DONE Lazy Sequences...........................................................................................77
CLOSED: [2011-09-20 mar. 13:30]
A lazy sequence is not resolved if not needed.
When resolved, a cache is used to keep the values resolved by the algorithm.
***** DONE An Example of Laziness.................................................................................. 78
CLOSED: [2011-09-19 lun. 08:02]
Map constructs lazy sequences as a default behaviour.
***** DONE Constructing Lazy Sequences ............................................................................ 80
CLOSED: [2011-09-19 lun. 08:02]
Use iterate, generator function, to help in generating lazy sequences.
***** DONE Lazy Sequences and Memory Management.................................................................... 82
CLOSED: [2011-09-19 lun. 13:45]
Beware using lazy sequences and defining lazy sequences.
As when a lazy sequences is resolved, a cache is used to keep the
values.
And so the heap grows.
If you do not need to keep references on lazy sequences, don't.
It will keep your memory clean.
*** DONE The Sequence API.........................................................................................83
CLOSED: [2011-09-20 mar. 13:30]
***** TODO Sequence Creation ...................................................................................... 83
*** DONE Summary .................................................................................................95
CLOSED: [2011-09-20 mar. 13:30]
* DONE Chapter 6: State Management [7/7] ..........................................................................95
CLOSED: [2011-09-27 mar. 07:26]
*** DONE State in an Immutable World .............................................................................95
CLOSED: [2011-09-20 mar. 18:12]
***** DONE The Old Way............................................................................................. 95
CLOSED: [2011-09-20 mar. 13:57]
lock hell!
***** DONE State and Identity ..................................................................................... 96
CLOSED: [2011-09-20 mar. 13:57]
Things are sliced in two concepts.
- Identity: constant that defines thing independently of time
- State: state is a value in time (snapshot) for an identity that do
  not change ever!
Each step creates a new step (new state) and the identity does not
change but the pointer is updated to the last state.
***** DONE State and Identity in Clojure .......................................................................... 96
CLOSED: [2011-09-20 mar. 18:12]
- Use refs to manage synchronous, coordinated states.
- Use agents to manage asynchronous, independent states.
- Use atoms to manage synchronous, independent states.
******* DONE Coordinated vs Independent state
CLOSED: [2011-09-20 mar. 17:58]
- Coordinated
  => to ensure data integrity (transactions in bank)
  => manage several inter-dependent identities
- independent => separate identities
******* DONE Synchronous vs asynchronous usage
CLOSED: [2011-09-20 mar. 18:11]
*** DONE Refs and Transactions ...................................................................................97
synchronous, coordinated identities.
CLOSED: [2011-09-21 mer. 07:52]
***** DONE Creating and Accessing refs............................................................................. 98
CLOSED: [2011-09-20 mar. 18:55]
***** DONE Updating refs .......................................................................................... 98
CLOSED: [2011-09-21 mer. 07:52]
******* DONE Transactions
CLOSED: [2011-09-20 mar. 18:56]
******* DONE Tools for updating refs
CLOSED: [2011-09-21 mer. 05:23]
- transaction nested inside the call of dosync.
- Use ref-set to update a completely new value to a reference
- Use alter to update the value of a ref, the idea here is to remind
that the new value comes from the old one.
- Use commute inside the transaction to use the new value of the ref
  even thought the transaction is not done. You behave as if you know
  that the transaction will be ok so it's ok to use the new value.
- Use ensure to 'lock' a ref that you do not want updated during the
  transaction time.
******* DONE Examples
CLOSED: [2011-09-21 mer. 07:48]
*** DONE Atoms...................................................................................................104
CLOSED: [2011-09-21 mer. 08:06]
synchronous, uncoordinated identities.
Behave like refs except that they do need to participate in transaction.
***** DONE Using Atoms ........................................................................................... 104
CLOSED: [2011-09-21 mer. 08:01]
***** DONE When to Use Atoms ..................................................................................... 105
CLOSED: [2011-09-21 mer. 08:01]
Independent identities.
Rapid for reading.
lightweight of the clojure identity types.
Use case: cache.
Internally used by clojure in the memoize function.
*** DONE Asynchronous Agents ....................................................................................105
CLOSED: [2011-09-27 mar. 07:09]
***** DONE Creating and Updating Agents........................................................................... 105
CLOSED: [2011-09-22 jeu. 07:17]
asynchronous
- storing and managing state in a concurrency env
- introducing concurrency
(def my-agent (agent 5))
@agent

(send my-agent 3 5); asynchronous call, rapid but undetermined time

; send -> for cpu intensive operation
; sendoff for an identical call but oriented for IO intensive call
; (optimized internally)

***** DONE Errors and Agents...................................................................................... 107
CLOSED: [2011-09-27 mar. 07:09]
***** DONE Waiting for Agents .................................................................................... 108
CLOSED: [2011-09-27 mar. 07:09]
***** DONE Shutting Down Agents .................................................................................. 108
CLOSED: [2011-09-27 mar. 07:09]
***** DONE When to Use Agents .................................................................................... 109
CLOSED: [2011-09-27 mar. 07:09]
*** DONE Vars and Thread-Local State ............................................................................109
CLOSED: [2011-09-27 mar. 07:09]
***** DONE When to Use Thread-Local Vars ......................................................................... 110
CLOSED: [2011-09-27 mar. 07:09]
*** DONE Keeping Track of Identities ............................................................................111
CLOSED: [2011-09-27 mar. 07:26]
***** DONE Validators............................................................................................. 111
CLOSED: [2011-09-27 mar. 07:18]
***** DONE Watches................................................................................................ 112
CLOSED: [2011-09-27 mar. 07:26]
*** DONE Summary ................................................................................................113
CLOSED: [2011-09-27 mar. 07:26]
* TODO Chapter 7: Namespaces and Libraries [0/21] .................................................................115
*** TODO Organizing Clojure Code ................................................................................115
*** TODO Namespace Basics .......................................................................................115
***** TODO Switching Namespaces with in-ns........................................................................ 115
***** TODO Referring to Other Namespaces ......................................................................... 116
*** TODO Loading Other Namespaces................................................................................117
***** TODO Loading from a File or Stream.......................................................................... 117
***** TODO Loading from the Classpath............................................................................. 118
***** TODO Loading and Referring Namespaces in One Step .......................................................... 120
***** TODO Importing Java Classes ................................................................................ 120
*** TODO Bringing It All Together: Namespace Declarations .......................................................121
*** TODO Symbols and Namespaces..................................................................................121
***** TODO Namespace Metadata..................................................................................... 122
***** TODO Forward Declarations .................................................................................. 122
***** TODO Namespace-Qualified Symbols and Keywords............................................................... 122
***** TODO Constructing Symbols and Keywords...................................................................... 123
***** TODO Public and Private Vars................................................................................ 123
*** TODO Advanced Namespace Operations...........................................................................124
***** TODO Querying Namespaces.................................................................................... 124
***** TODO Manipulating Namespaces ............................................................................... 125
*** TODO Namespaces As References ...............................................................................126
*** TODO Summary ................................................................................................126
* TODO Chapter 8: Metadata [0/8] ..................................................................................127
*** TODO Reading and Writing Metadata ...........................................................................127
*** TODO Metadata-Preserving Operations..........................................................................128
*** TODO Read-Time Metadata .....................................................................................129
*** TODO Metadata on Vars........................................................................................129
***** TODO Type Tags ............................................................................................. 131
***** TODO Private Vars .......................................................................................... 131
*** TODO Metadata on Reference Types ............................................................................131
*** TODO Summary ................................................................................................131
* TODO Chapter 9: Multimethods and Hierarchies [0/12] .............................................................133
*** TODO Multimethods............................................................................................133
***** TODO Multiple Dispatch...................................................................................... 135
***** TODO Default Dispatch Values................................................................................ 135
*** TODO Hierarchies ............................................................................................136
***** TODO Querying Hierarchies .................................................................................. 137
*** TODO Hierarchies with Multimethods...........................................................................137
***** TODO Hierarchies with Java Classes.......................................................................... 138
***** TODO More Hierarchy Queries................................................................................. 139
***** TODO Resolving Conflicts ................................................................................... 139
***** TODO Type Tags ............................................................................................. 141
*** TODO User-Defined Hierarchies ...............................................................................141
*** TODO Summary ................................................................................................142
* TODO Chapter 10: Java Interoperability [0/12] ...................................................................143
*** TODO Calling Java from Clojure...............................................................................143
***** TODO Java Interop Special Forms ............................................................................ 143
***** TODO Java Interop Preferred Forms........................................................................... 144
***** TODO Clojure Types and Java Interfaces...................................................................... 145
***** TODO Java Arrays............................................................................................ 146
*** TODO Calling Clojure from Java...............................................................................148
***** TODO Loading and Evaluating Clojure Code ................................................................... 149
***** TODO Using Clojure Functions and Vars....................................................................... 149
*** TODO Creating Java Classes ..................................................................................150
***** TODO Proxying Java Classes ................................................................................. 150
***** TODO Generating Java Classes ............................................................................... 151
*** TODO Summary ................................................................................................157
* TODO Chapter 11: Parallel Programming [0/13] ....................................................................159
*** TODO Parallelism in Clojure..................................................................................159
*** TODO Agents..................................................................................................159
***** TODO Agent Thread Pools..................................................................................... 159
***** TODO Agent Example.......................................................................................... 160
***** TODO Concurrent Agent Performance .......................................................................... 161
*** TODO Concurrency Functions ..................................................................................161
***** TODO Overhead and Performance............................................................................... 162
*** TODO Futures and Promises....................................................................................163
***** TODO Futures ............................................................................................... 163
***** TODO Promises............................................................................................... 164
*** TODO Java-based Threading ...................................................................................165
***** TODO Creating a Thread ..................................................................................... 165
*** TODO Summary ................................................................................................166
* TODO Chapter 12: Macros and Metaprogramming [0/11] ..............................................................167
*** TODO What Is Metaprogramming? ...............................................................................167
***** TODO Code vs. Data.......................................................................................... 167
***** TODO Homoiconicity.......................................................................................... 167
*** TODO Macros..................................................................................................168
***** TODO Working with Macros.................................................................................... 169
***** TODO Code Templating........................................................................................ 171
***** TODO Generating Symbols .................................................................................... 172
***** TODO When to Use Macros..................................................................................... 173
***** TODO Using Macros........................................................................................... 173
***** TODO Using Macros to Create DSLs ........................................................................... 177
*** TODO Summary ................................................................................................178
* TODO Chapter 13: Datatypes and Protocols [0/14] .................................................................179
*** TODO Protocols...............................................................................................179
***** TODO Protocols As Interfaces................................................................................ 180
*** TODO Datatypes...............................................................................................180
***** TODO Implementing Protocols and Interfaces...................................................................181
***** TODO In-Line Methods........................................................................................ 181
***** TODO Extending Java Interfaces ............................................................................. 182
*** TODO Datatypes As Classes .................................................................................. 183
***** TODO Extending Protocols to Pre-Existing Types ..............................................................183
*** TODO Extending Java Classes and Interfaces ................................................................. 184
*** TODO Reifying Anonymous Datatypes ...........................................................................184
*** TODO Working with Datatypes and Protocols....................................................................185
***** TODO A Complete Example..................................................................................... 186
*** TODO Advanced Datatypes .....................................................................................186
*** TODO Summary ................................................................................................187
* TODO Chapter 14: Performance [0/15] .............................................................................189
*** TODO Profiling on the JVM....................................................................................189
***** TODO General Tips for Java Performance ..................................................................... 189
***** TODO Simple Profiling with Time ............................................................................ 190
***** TODO Using Java Profiling Tools ............................................................................ 190
*** TODO Memoization ............................................................................................191
*** TODO Reflection and Type Hints...............................................................................191
*** TODO Working with Primitives.................................................................................193
***** TODO Loop Primitives........................................................................................ 193
***** TODO Unchecked Integer Arithmetic .......................................................................... 194
***** TODO Primitive Arrays ...................................................................................... 195
*** TODO Transients..............................................................................................195
*** TODO Var Lookups ............................................................................................196
*** TODO Inlining ...............................................................................................197
***** TODO Macros and definline .................................................................................. 197
*** TODO Summary ................................................................................................197
* TODO Index ......................................................................................................199

