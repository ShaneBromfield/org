#+Title: practical clojure
#+author: Antoine Romain Dumont
#+STARTUP: indent
#+STARTUP: hidestars odd

* DONE About the Authors.......................................................................................... xiv
* DONE About the Technical Reviewer .............................................................................. xv
* DONE Acknowledgments ........................................................................................... xvi
* DONE Chapter 1: The Clojure Way [3/3] .............................................................................1
*** DONE Clojure’s Philosophy and Special Features ................................................................1
***** DONE A Next-Generation Language................................................................................ 1
The future so why fight it!?
***** DONE Dynamic and Powerful (Yes, It’s a Lisp) .................................................................. 1
ugly for some but excellent for others, clojure is awsome as a lisp language.
***** DONE The Java Platform......................................................................................... 2
The jvm is a real good piece of software. Clojure uses it at its advantages.
*** DONE Functional Programming [8/8] .............................................................................2
***** DONE Purely Functional Programming ............................................................................ 4
Based on pure function:
- only inputs (parameters) and output
- no interaction with the outside
- no state
- more simple to test
- black box
***** DONE Clojure’s Compromise ..................................................................................... 6
Coding purely functional functions is impossible but clojure tends
towards it as much as it can.
As clojure can manipulate java objects, there is no purity (java
objects are by definition stateful) when
manipulating those.
***** DONE Immutability.............................................................................................. 7
Structures are immutable.
When needed to change, a new object is copied but share the common
structure - this shared structure is called persitence.
The old shared structure which is not shared anymore will be silently garbage collected.

Many structures:
- Linked list
- Vectors
- Hash maps
- Sorted maps
- Hash and sorted sets
***** DONE What about Object-Oriented Programming? .................................................................. 9
- Clojure is not object oriented.
    - mutability
    - no facility in code modularization and abstraction -> spaghetti code
    - inheritance is fragile and can be dangerous
    - code bloat -> needs some frameworks to improve the code -> more
      boilerplates and interface not serving the soft...
- Clojure shares the good parts of the OO paradigm
    - modularity
    - polymorphism
    - encapsulation
    - reusability
- Another difference
***** DONE Structure of a clojure program .......................................................................... 10
***** DONE State Management ........................................................................................ 11
stateful objects == new spaghetti code
***** DONE State and Identity ...................................................................................... 12
***** DONE Software Transactional Memory ........................................................................... 13
*** DONE Summary .................................................................................................15
* TODO Chapter 2: The Clojure Environment ..........................................................................17
* TODO Chapter 3: Controlling Program Flow .........................................................................29
* TODO Chapter 4: Data in Clojure...................................................................................51
* TODO Chapter 5: Sequences ........................................................................................73
* TODO Chapter 6: State Management .................................................................................95
* TODO Chapter 7: Namespaces and Libraries.........................................................................115
* TODO Chapter 8: Metadata ........................................................................................127
* TODO Chapter 9: Multimethods and Hierarchies ....................................................................133
* TODO Chapter 10: Java Interoperability...........................................................................143
* TODO Chapter 11: Parallel Programming ...........................................................................159
* TODO Chapter 12: Macros and Metaprogramming......................................................................167
* TODO Chapter 13: Datatypes and Protocols ........................................................................179
* TODO Chapter 14: Performance.....................................................................................189
* TODO Index ......................................................................................................199
