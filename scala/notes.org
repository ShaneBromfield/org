#+title: Functional programming principles in Scala
#+author: Antoine R. Dumont

* DONE Tools Setup for linux
CLOSED: [2013-07-22 Mon 09:09]
* DONE Tutorial working on the programming assignments
CLOSED: [2013-07-22 Mon 09:09]
* DONE Programming paradigms
CLOSED: [2013-07-22 Mon 09:09]
* DONE Elements of programming
CLOSED: [2013-07-22 Mon 09:09]
* DONE Evaluation strategies and termination
CLOSED: [2013-07-22 Mon 09:09]
Call By Name ->
Call By Value -> evaluate first the parameters

if CBV terminates then CBN terminates
Not true for the other way around

Scala defaults to CBV, you can force the evaluation strategy to CBN by adding =>
* DONE Conditionals and value definition
CLOSED: [2013-07-22 lun. 11:22]
** if-else
#+begin_src scala
def abs(x: Int) = if (x>=0) x else -x
#+end_src
** boolean expressions
#+begin_src scala
true
false
!b
b && b
b || b
e <= e
...
#+end_src

short-circuit evaluation (&& ||)
** value definitions
- def function definition by name
- val/var variable/form definition by value

Exemple:
#+begin_src scala
def x = loop
#+end_src

#+begin_src scala
val x = loop
#+end_src
ko, will never render the hand

** Exercise

By value:
#+begin_src scala
def and(x: Boolean, y: Boolean) = if x y else False
#+end_src

But, this =and(x, loop)= will break as scala is by value by default.

Redefining, by defining the y by name:

#+begin_src scala
def and(x: Boolean, y: => Boolean) = if x y else False
#+end_src

this will be ok and do not try to evaluate the loop expression.

* DONE Example square roots with Newton's method
CLOSED: [2013-07-22 lun. 12:00]
Successive approximations
- Start with an initial estimate y (y = 1 for starter)
- Repeatedly improve the estimate by taking the mean of y and x/y

#+begin_src scala
package coursera

import math.abs

object session {

  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double) =
    abs(guess * guess - x) / x < 0.001

  def improve(guess: Double, x: Double) =
    (guess + x/guess) / 2

  def sqrt(x: Double) = sqrtIter(1.0, x)

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20/*, 1.0e50*/)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.session 4
// List(2.0, 1.4142156862745097)
// List(4.0, 2.0000000929222947)
// List(1.0E-6, 0.031260655525445276)
// List(0.001, 0.04124542607499115)
// List(1.0E-21, 0.03125)
// List(1.0E20, 1.0E10)
// sqrt(1.0E20): 1.0E10
// ^D^D  C-c C-c^C
// Process sbt exited abnormally with code 130
#+end_src

1. the =isGoodEnough= test is not very precise for small numbers and can lead to non-termination for very large numbers. Explain why.

- takes absolute difference
- small numbers: the threshold value 0.001 might be too huge
- large numbers: further apart than this absolute value (distance might be larger than the threshold)
- we can make test proportional to x


2. Design a different version of =isGoodEnough= that does not have these problems.

3. Test your version with some very very small and large numbers e.g.
0.001
0.1e-20
1.0e20
1.0e50

#+begin_src scala
package coursera

import math.abs

object session {

  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double) =
    abs(guess * guess - x) / x < 0.001

  def improve(guess: Double, x: Double) =
    (guess + x/guess) / 2

  def sqrt(x: Double) = sqrtIter(1.0, x)

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20, 1.0e50)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.session
// List(2.0, 1.4142156862745097)
// List(4.0, 2.000609756097561)
// List(1.0E-6, 0.0010000001533016628)
// List(0.001, 0.03162278245070105)
// List(1.0E-21, 3.1633394544890125E-11)
// List(1.0E20, 1.0000021484861237E10)
// List(1.0E50, 1.0000003807575104E25)
// [success] Total time: 1 s, completed 22 juil. 2013 11:43:47
#+end_src

* DONE Blocks and lexical scope
CLOSED: [2013-07-22 lun. 12:22]
** nested functions
- split up task into many small functions
- avoid namespace pollution
- to do this in scala, put those private functions into the main function

For example, for the sqrt sample:
#+begin_src scala
package coursera

import math.abs

object session {

  def sqrt(x: Double) = {
    def sqrtIter(guess: Double, x: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess, x), x)

    def isGoodEnough(guess: Double, x: Double) =
      abs(guess * guess - x) / x < 0.001

    def improve(guess: Double, x: Double) =
      (guess + x/guess) / 2

    sqrtIter(1.0, x)
  }

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20, 1.0e50)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.session
// List(2.0, 1.4142156862745097)
// List(4.0, 2.000609756097561)
// List(1.0E-6, 0.0010000001533016628)
// List(0.001, 0.03162278245070105)
// List(1.0E-21, 3.1633394544890125E-11)
// List(1.0E20, 1.0000021484861237E10)
// List(1.0E50, 1.0000003807575104E25)
// [success] Total time: 1 s, completed 22 juil. 2013 11:58:50
#+end_src

For this, we use a block.
** scope rules
Inside a block, as long as not shadowed, the function/variables defined are visibles inside nested blocks.

* DONE Tail recursion
CLOSED: [2013-07-22 lun. 14:57]
Application rewriting rule
substitution of all occurences of parameters by their corresponding values

Ex:

Tail recursion:
#+begin_src scala
  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
#+end_src

No tail recursion as there exists some operations to be done after the recursion call.
#+begin_src scala
  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial (n-1)
#+end_src

Tail recursion -> if a function calls itself as its last action, the function's stack frame can be reused.

Define a tail-recursive version of the factorial
#+begin_src scala
...
  def factorial(n: Int): Int = {
    @tailrec
    def fact(n: Int, r: Int): Int =
      if (n == 0) r else fact(n-1, n*r)

    fact(n, 1)
  }
...
#+end_src

* DONE Higher-order functions
CLOSED: [2013-07-22 lun. 15:53]
** definition
- functions as first-class values:
  - functions can be passed as parameters to function
  - functions can be returned as result of function
- functions that takes functions as parameters are called Higher-order functions.

Provides flexible way to compose programs
** Examples
#+begin_src scala
package coursera

object w3 {
  // sum of the integers between a and b
  def sumInts(a: Int, b: Int): Int =
    if(a > b) 0 else a + sumInts(a + 1, b)

  def sumCubes(a: Int, b: Int) :Int = {
    def cube(a: Int): Int = a * a * a

    def sum(a: Int, b: Int): Int =
      if(a > b) 0 else cube(a) + sum(a + 1, b)

    sum(a, b)
  }

  def sumFactorials(a: Int, b: Int): Int =
    if(a > b) 0 else w2.factorial(a) + sumFactorials(a + 1, b)

  def main(args: Array[String]) = {
    println(sumInts(1, 10))
    println(sumCubes(1, 10))
    println(sumFactorials(1, 10))
  }
}

// [info] Running coursera.w3
// 55
// 3025
// 4037913
// [success] Total time: 0 s, completed 22 juil. 2013 15:08:24
#+end_src

** Factor out common patterns?

#+begin_src scala
package coursera

object w3 {
  def sum(a: Int, b: Int, fn: Int => Int): Int =
    if(a > b) 0 else fn(a) + sum(a + 1, b, fn)

  // sum of the integers between a and b
  def sumInts(a: Int, b: Int): Int =
    sum(a, b, identity)

  def sumCubes(a: Int, b: Int) :Int = {
    def cube(a: Int): Int = a * a * a

    sum(a, b, cube)
  }

  def sumFactorials(a: Int, b: Int): Int =
    sum(a, b, w2.factorial)

  def main(args: Array[String]) = {
    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sumInts,
          "sumCubes"      -> sumCubes,
          "sumFactorials" -> sumFactorials)

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("end")
  }
}

// [info] Running coursera.w3
// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### end

// [success] Total time: 2 s, completed 22 juil. 2013 15:38:09
#+end_src


** Anonymous function
syntactic sugar

We can for example avoid 'def'ining the `cube` version:
#+begin_src scala
  def sumCubes(a: Int, b: Int) :Int =
    sum(a, b, (x: Int) => x * x * x)
#+end_src

We can also let the compiler infer the type
#+begin_src scala
  def sumCubes(a: Int, b: Int) :Int =
    sum(a, b, x => x * x * x)
#+end_src

** define the tail recursive version of the sum function

#+begin_src scala
  def sum(a: Int, b: Int, fn: Int => Int): Int = {

    @tailrec
    def sumTR(x: Int, r: Int): Int =
      if(x > b) r else sumTR(x + 1, fn(x) + r)

    sumTR(a, 0)
  }

#+end_src

* DONE Currying
CLOSED: [2013-07-22 lun. 18:24]

** Can we remove the redundant bounds parameters?
Yes

by redefining the `sum` function to return another function which takes the 2 bounds parameters:
#+begin_src scala
  def sum(fn: Int => Int): (Int, Int) => Int = {

    @tailrec
    def sumTR(a: Int, b: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, b, fn(a) + r)

    (a, b) => sumTR(a, b, 0)
  }
#+end_src

Thus, this simplifies the definition of the functions that rely on `sum`:
#+begin_src scala
  def sumInts = sum(identity)
  def sumCubes = sum(x => x * x * x)
  def sumFactorials = sum(w2.factorial)
#+end_src

Complete package:
#+begin_src scala
package coursera

import scala.annotation.tailrec

object w3 {
  def sum(fn: Int => Int): (Int, Int) => Int = {

    @tailrec
    def sumTR(a: Int, b: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, b, fn(a) + r)

    (a, b) => sumTR(a, b, 0)
  }

  // sum of the integers between a and b
  def sumInts = sum(identity)

  def sumCubes = sum(x => x * x * x)

  def sumFactorials = sum(w2.factorial)

  def main(args: Array[String]) = {
    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sumInts,
          "sumCubes"      -> sumCubes,
          "sumFactorials" -> sumFactorials)

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("end")
  }
}

// [info] Running coursera.w3
// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### end

// [success] Total time: 1 s, completed 22 juil. 2013 16:04:58
#+end_src

** Can we remove the middlemen function?
Yes!

#+begin_src scala
package coursera

import scala.annotation.tailrec

object w3 {
  def sum(fn: Int => Int): (Int, Int) => Int = {

    @tailrec
    def sumTR(a: Int, b: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, b, fn(a) + r)

    (a, b) => sumTR(a, b, 0)
  }

  def main(args: Array[String]) = {
    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sum(identity),
          "sumCubes"      -> sum(x => x * x * x),
          "sumFactorials" -> sum(w2.factorial))

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("end")
  }
}

// [info] Running coursera.w3
// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### end

// [success] Total time: 0 s, completed 22 juil. 2013 16:10:28
#+end_src

** Simplification over the definition of function that returns function
#+begin_src scala
  def sum(fn: Int => Int) (a: Int, b: Int): Int = {

    @tailrec
    def sumTR(a: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, fn(a) + r)

    sumTR(a, 0)
  }
#+end_src

** Exercises
1. Write a product function `pdt` that calculates the product of the values of a function for the points on a given interval

#+begin_src scala
  def pdt(fn: Int => Int) (a: Int, b: Int): Int = {
    @tailrec
    def loop(a: Int, r: Int): Int =
      if(a > b) r else loop(a + 1, fn(a) * r)

    loop(a, 1)
  }
#+end_src

2. Write factorial in terms of `pdt`

#+begin_src scala
  def factorial(n: Int) = pdt(identity)(1, n)
#+end_src

3. Can you write a more general function, which generalizes both `sum` and `pdt`?

#+begin_src scala
package coursera

import scala.annotation.tailrec

object w3 {
  def fold(fn: Int => Int, op: (Int, Int) => Int, initial: Int)(a: Int, b: Int): Int = {
    @tailrec
    def loop(a: Int, r: Int): Int =
      if(a > b) r else loop(a + 1, op(fn(a), r))

    loop(a, initial)
  }

  def sum(fn: Int => Int) (a: Int, b: Int): Int = fold(fn, (x, y) => x + y, 0)(a, b)
  def pdt(fn: Int => Int) (a: Int, b: Int): Int = fold(fn, (x, y) => x * y, 1)(a, b)

  def factorial(n: Int) = pdt(identity)(1, n)

  def main(args: Array[String]) = {
    w2.title("sum of a function values (cube, factorial, etc...)")

    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sum(identity),
          "sumCubes"      -> sum(x => x * x * x),
          "sumFactorials" -> sum(factorial))

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("factorial")

    val fvalues = List(1,2,3,4,5,6,7,8,9)

    fvalues.map(factorial).map(println)

    w2.title("end")
  }
}

// ######### sum of a function values (cube, factorial, etc...)

// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### factorial

// 1
// 2
// 6
// 24
// 120
// 720
// 5040
// 40320
// 362880

// ######### end

// [success] Total time: 1 s, completed 22 juil. 2013 18:19:56
#+end_src

* DONE Example finding fixed points
CLOSED: [2013-07-23 mar. 08:47]
a number x is called a fixed point of a function if f(x) = x

for some functions f, we can locate the fixed points by starting with an initial estimate and then by applying f in a repetitive way: iterate f x

until the value does not vary anymore (or the changes is sufficiently small)
#+begin_src scala
package coursera

import math.abs

object w32 {
  val tolerance = 0.0001

  def isCloseEnough(x: Double, y: Double): Boolean =
    abs((x - y) / x) / x < tolerance

  def fixedPoint(f: Double => Double) (firstGuess: Double) = {
    def iterate(guess: Double): Double = {
      val next = averageDamp(f)(guess)
      if(isCloseEnough(guess, next)) next else iterate(next)
    }
    iterate(firstGuess)
  }

  def averageDamp(f: Double => Double)(x: Double) :Double =
    (x + f(x)) / 2

  def main(args: Array[String]) = {
    println(fixedPoint(x => 1 + x/2)(1))
  }
}

// [info] Running coursera.w32
// 1.999755859375
// [success] Total time: 3 s, completed 22 juil. 2013 18:44:11
#+end_src

Revisiting the square root:

#+begin_src scala
package coursera

import math.abs

object w1 {

  def sqrt(x: Double) = w32.fixedPoint(y => x/y)(1.0)

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20, 1.0e50)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.w1
// List(2.0, 1.4142135623746899)
// List(4.0, 2.000000000000002)
// List(1.0E-6, 0.001)
// List(0.001, 0.03162277660168433)
// List(1.0E-21, 3.162277660168379E-11)
// List(1.0E20, 2.5E19)
// List(1.0E50, 2.5E49)
// [success] Total time: 2 s, completed 22 juil. 2013 18:52:31

#+end_src


* TODO scala syntax summary
* TODO functions and data
* TODO More fun with rationals
* TODO Evaluation and operators
* TODO Class hierarchies
