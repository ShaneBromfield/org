#+TITLE: Functional Approach in haskell - Ch1
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, programming, functional-programming
#+DESCRIPTION: Learning algorithms using haskell
#+STARTUP: indent
#+STARTUP: hidestars odd

Now that i know a little more about haskell, I can go and refresh my memory about algorithms but the functional way.
So, I came accross functional approach in haskell which does exactly that.

Here are the first exercises (focused on haskell for the moment).

* Simple
#+begin_quote
Using a haskell interpreter, evaluate the following expressions (try to predict the result):
(1+2)
if (2 > 9) then "hello" else "bye"
let x=(sqrt 16) in x+1
#+end_quote

#+begin_src haskell
(1+2)                               - 3
if (2 > 9) then "hello" else "bye"  - "bye"
let x=(sqrt 16) in x+1              -  5.0

#+end_src

Interpreter:
#+begin_src haskell
*Ch1> 1 + 2
3
*Ch1> if (2 > 9) then "hello" else "bye"
"bye"
*Ch1> let x=(sqrt 16) in x+1
5.0
#+end_src

*
#+begin_quote
Define and load the following function:
=fact 1 = 1=
=fact n = n * fact (n-1)=

a) Using the interpreter, evaluate the expression =fact 5=
b) What happens when you try to evaluate =fact 0=? Alter the above definition to solve this definition.
c) Modify your definition such that the value -1 is returned when an attempt is made to compute the factorial of a negative value.
#+end_quote

a)
#+begin_src haskell
*Ch1> fact 5
120
#+end_src

b)
- the function does not terminate
- alter:
#+begin_src haskell
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
#+end_src

c)
Compute factorial of a negative value must render -1:
#+begin_src haskell
fact :: Int -> Int
fact n
  | n < 0     = -1
  | n == 0    = 1
  | otherwise = n * fact (n-1)

*Ch1> fact 0
1
*Ch1> fact 1
1
*Ch1> fact 5
120
*Ch1> fact (-10)
-1
#+end_src

* wrong
#+begin_quote
What is wrong with the following expressions? Can you change them to make them valid?

1:2:3
[ [2,3] ++ [], [2,3]:[] ]
"hello" : "world"
#+end_quote

#+begin_src haskell
*Ch1> (1:2:3:[])
[1,2,3]
*Ch1> [[[2,3] ++ []], ([2,3]:[])]
[[[2,3]],[[2,3]]]
*Ch1> "hello" ++ "world"
"helloworld"
#+end_src

* reverse
#+begin_quote
Given the following function:
#+end_quote
#+begin_src haskell
f l = reverse (f' l [])
      where f' [] r     = r
            f' (x:xs) r = (2*x) : (f' xs r)
#+end_src
#+begin_quote
What is the value of =f [1,2,3,4])= ?
Check your answer with the haskell interpreter.
#+end_quote

Answer step by step:
#+begin_src haskell
f [1,2,3,4] = reverse (f' [1,2,3,4] [])
            = reverse ((2*1) : (f' [2,3,4] []))
            = reverse (2 : (2*2) : (f' [3,4] []))
            = reverse (2 : 4 : (2*3) : (f' [4] []))
            = reverse (2 : 4 : 6 : (4*2) : (f' [] []))
            = reverse (2 : 4 : 6 : 8 : [])
            = [8,6,4,2]
#+end_src

Interpreter:
#+begin_src haskell
*Ch1> f [1..4]
[8,6,4,2]
#+end_src

* Predict
#+begin_quote
Try to predict the value of the following expressions:
=[1,2,3] ++ [4]=
=1:(2:(3:[4]))=
=head [1,2,3]=
=tail [1,2,3]=
=drop 4 [1,2,3,4,5]=
=[1,2,3,4] !! 2=
#+end_quote

#+begin_src haskell
[1,2,3] ++ [4]          -- [1,2,3,4]
1:(2:(3:[4]))           -- [1,2,3,4]
head [1,2,3]            -- 1
tail [1,2,3]            -- [2,3]
drop 4 [1,2,3,4,5]      -- [5]
[1,2,3,4] !! 2          -- 3
#+end_src
