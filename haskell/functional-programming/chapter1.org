#+TITLE: Functional Approach in haskell - Ch1
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, programming, functional-programming
#+DESCRIPTION: Learning algorithms using haskell
#+STARTUP: indent
#+STARTUP: hidestars odd

Now that i know a little more about haskell, I can go and refresh my memory about algorithms but the functional way.
So, I came accross functional approach in haskell which does exactly that.

Here are the first exercises (focused on haskell for the moment).

* Simple
#+begin_quote
Using a haskell interpreter, evaluate the following expressions (try to predict the result):
(1+2)
if (2 > 9) then "hello" else "bye"
let x=(sqrt 16) in x+1
#+end_quote

#+begin_src haskell
(1+2)                               - 3
if (2 > 9) then "hello" else "bye"  - "bye"
let x=(sqrt 16) in x+1              -  5.0

#+end_src

Interpreter:
#+begin_src haskell
*Ch1> 1 + 2
3
*Ch1> if (2 > 9) then "hello" else "bye"
"bye"
*Ch1> let x=(sqrt 16) in x+1
5.0
#+end_src

*
#+begin_quote
Define and load the following function:
=fact 1 = 1=
=fact n = n * fact (n-1)=

a) Using the interpreter, evaluate the expression =fact 5=
b) What happens when you try to evaluate =fact 0=? Alter the above definition to solve this definition.
c) Modify your definition such that the value -1 is returned when an attempt is made to compute the factorial of a negative value.
#+end_quote

a)
#+begin_src haskell
*Ch1> fact 5
120
#+end_src

b)
- the function does not terminate
- alter:
#+begin_src haskell
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
#+end_src

c)
Compute factorial of a negative value must render -1:
#+begin_src haskell
fact :: Int -> Int
fact n
  | n < 0     = -1
  | n == 0    = 1
  | otherwise = n * fact (n-1)

*Ch1> fact 0
1
*Ch1> fact 1
1
*Ch1> fact 5
120
*Ch1> fact (-10)
-1
#+end_src
