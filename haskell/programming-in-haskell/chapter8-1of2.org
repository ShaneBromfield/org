#+BLOG: tony-blog
#+POSTID: 997
#+DATE: [2013-04-12 ven. 11:59]
#+TITLE: PIH - ch8 1/2 - Functional parsers - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars odd

It has been a moment since I post some haskell exercises.
At last, here it is:

I did encounter some troubles for this.
The definition used in this chapter and the reality were slightly changed.

Anyway, here are the needed definitions for tinkering with parsers in your repl:

#+begin_src haskell
import Control.Monad
import Data.Char(isDigit, isUpper, isLower, isAlpha, isAlphaNum, isSpace)

newtype Parser a  =  P (String -> [(a,String)])

parse             :: Parser a -> String -> [(a,String)]
parse (P p) inp   =  p inp

instance Monad Parser where
  -- return parser: always succeeds by returning the result value
  -- v without consuming the input
    return v      =  P (\inp -> [(v,inp)])

  -- bind
    p >>= f       =  P (\inp -> case parse p inp of
                       []        -> []
                       [(v,out)] -> parse (f v) out)

instance MonadPlus Parser where
  -- fail
    mzero         =  P (\_ -> [])
  -- choice
    p `mplus` q   =  P (\inp -> case parse p inp of
                       []        -> parse q inp
                       [(v,out)] -> [(v,out)])

#+end_src
I will not enter into details here because monads will be presented in another late chapter.

As always, you'll find the [[https://github.com/ardumont/my-haskell-lab/blob/master/src/ch8.hs][sources on github]].

* int :: Parser Int
#+BEGIN_QUOTE
The library file also defines a parser =int :: Parser Int= for an integer. Without looking at this definition, define int.

Hint: an integer is either a minus symbol followed by a natural number, or a natural number.
#+END_QUOTE

Used functions:
#+begin_src haskell

many :: Parser a -> Parser [a]
many p = many1 p +++ return []

many1 :: Parser a -> Parser [a]
many1 p = do v  <- p
             vs <- many p
             return (v:vs)

sat :: (Char -> Bool) -> Parser Char
sat p = do x <- item; if p x then return x else Parsers.fail

nat :: Parser Int
nat = do xs <- many1 digit
         return (read xs)

space :: Parser ()
space = do many (sat isSpace)
           return ()

token :: Parser a -> Parser a
token p = do space
             x <- p
             space
             return x

natural :: Parser Int
natural = token nat

string :: String -> Parser String
string [] = return []
string (x:xs) = do char x
                   string xs
                   return (x:xs)

symbol :: String -> Parser String
symbol s = token (string s)

#+end_src

We have a 'choice' between parsing a negative natural number (beginning with '-') or a positive natural number.
#+begin_src haskell
int :: Parser Int
int = do symbol "-"
         n <- natural
         return (-n)
         +++ natural
#+end_src

Examples:
#+begin_src haskell
*Parsers> parse int "-1"
[(-1,"")]
*Parsers> parse int "-10"
[(-10,"")]
*Parsers> parse int "-101"
[(-101,"")]
*Parsers> parse int "101"
[(101,"")]
*Parsers> parse int " - 101"
[(-101,"")]
#+end_src

* comment :: Parser ()
#+begin_quote
Define a parser =comment :: Parser ()= for ordinary Haskell comments that begin with the symbol -- and extend to the end of the current line, which is represented by the control character ’\n’.
#+end_quote

Here are the functions I will use to answer the question:
#+begin_src haskell

char :: Char -> Parser Char
char x = sat (== x)

alphanum :: Parser Char
alphanum = sat isAlphaNum
#+end_src

Here is a first naive approach where you specify the characters you can read:
#+begin_src haskell

comment :: Parser ()
comment = do symbol "--"
             many (alphanum +++ char ' ')
             char '\n'
             return ()
#+end_src

#+begin_src haskell
*Parsers> parse comment "--thisisacommentignoredtill\nnotignored"
[((),"notignored")]
*Parsers> parse comment "--this is a comment ignored till\nnotignored"
[((),"notignored")]
*Parsers> parse comment "--this is a  comment ignored till\nnotignored"
[((),"notignored")]
*Parsers> parse comment "--this is a  comment ignored 23 till\nnotignored"
[((),"notignored")]
#+end_src

Indeed, for some edge cases, this won't work:
#+begin_src haskell
*Parsers> parse comment "--this is a  comment!@# that breaks\nnotignored"
[]
#+end_src

A simpler and better approach would be to parse anything that's not the ending control char '\n':

#+begin_src haskell
comment :: Parser ()
comment = do symbol "--"
             many (sat (/= '\n'))
             char '\n'
             return ()
#+end_src

#+begin_src haskell
*Parsers> parse comment "--this is a  comment!@# that does not break\nnotignored"
[((),"notignored")]
#+end_src

* Draw Tree 1/2
#+begin_quote
Using our second grammar for arithmetic expressions, draw the two possible parse trees for the expression =2 + 3 + 4=.
#+end_quote

* Draw Tree 2/2
#+begin_quote
Using our third grammar for arithmetic expressions, draw the parse trees for the expressions =2 + 3=, =2 ∗ 3 ∗ 4= and =(2 + 3) + 4=.
#+end_quote
