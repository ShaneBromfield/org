#+BLOG: tony-blog
#+POSTID: 886
#+DATE: [2013-01-03 jeu. 19:36]
#+TITLE: Programming in haskell - ch7 - Higher-order functions
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

* Higher-order functions
#+begin_quote
Show how the list comprehension =[ f x | x ← xs, p x ]= can be re-expressed using the higher-order functions *map* and *filter*.
#+end_quote

What does the list comprehension do?
- filter all elements from *xs* according to the predicate *p*
- then apply *f* on the remaining elements

#+begin_src haskell
fmap0 :: (a -> a) -> (a -> Bool) -> [a] -> [a]
fmap0 f p xs = [ f x | x <- xs, p x]
#+end_src

Here is an example with:
- =(+1)= as the function =f=,
- =even= as the predicate =p=
- =[1..10]= as the list =xs=

#+begin_src haskell
*Ch7> fmap0 (+1) even [1..10]
[3,5,7,9,11]
#+end_src

With the preceding definition, we can indeed write the same definition using =map= and =filter=:

#+begin_src haskell
fmap1 :: (a -> a) -> (a -> Bool) -> [a] -> [a]
fmap1 f p xs = map f (filter p xs)
#+end_src

Using the same example:

#+begin_src haskell
*Ch7> fmap1 (+1) even [1..10]
[3,5,7,9,11]
#+end_src

* Define HOF
#+begin_quote
Without looking at the definitions from the standard prelude, define the
higher-order functions *all*, *any*, *takeWhile*, and *dropWhile*.
#+end_quote

** all
Recall the =and= function:

#+begin_src haskell
and :: [Bool] -> Bool
and = foldl (&&) True
#+end_src

So composing the mapping of the predicate =p= to the =and= function will do the trick.

#+begin_src haskell
all :: (a -> Bool) -> [a] -> Bool
all p = and . map p
#+end_src

Example:
*Ch7> all even [1,2,4]
False
*Ch7> all even [0,2,4]
True

** any

#+begin_src haskell
any :: (a -> Bool) -> [a] -> Bool
any p = or . map p
#+end_src

#+begin_src haskell
*Ch7> any odd [0,2,1]
True
*Ch7> any odd [0,2,4]
False
#+end_src

** takeWhile
** dropWhile

* map, filter
#+begin_quote
Redefine the functions *map f* and *filter p* using *foldr*.
#+end_quote

* dec2int
#+begin_quote
Using *foldl*, define a function =dec2int :: [ Int ] → Int=
that converts a decimal number into an integer.

For example:
#+begin_src haskell
> dec2int [2, 3, 4, 5]
2345
#+end_src
#+end_quote

* Invalid definition
#+begin_quote
Explain why the fopllowing definition is invalid:
#+begin_src haskell
sumsqreven = compose [sum, map (↑2), filter even]=
#+end_src
#+end_quote

* curry/uncurry
#+begin_quote
Without looking at the standard prelude, define the higher-order library
function curry that converts a function on pairs into a curried function, and,
conversely, the function uncurry that converts a curried function with two
arguments into a function on pairs.

*Hint:*
First write down the types of the two functions.
#+end_quote

* unfold
#+begin_quote
A higher-order function *unfold* that encapsulates a simple pattern of recursion
for producing a list can be defined as follows:
#+begin_src haskell
unfold p h t x | p x = []
               | otherwise = h x : unfold p h t (t x )
#+end_src

That is, the function =unfold p h t= produces the empty list if the predicate =p= is
true of the argument, and otherwise produces a non-empty list by applying
the function =h= to give the head, and the function =t= to generate another
argument that is recursively processed in the same way to produce the tail of
the list.

For example, the function *int2bin* can be rewritten more compactly
using *unfold* as follows:
#+begin_src haskell
int2bin = unfold (== 0) (‘mod ‘2) (‘div ‘2)
#+end_src

Redefine the functions *chop8*, *map f* and *iterate f* using unfold.
#+end_quote

** chop8
** map f
** iterate f

* transmitter
#+begin_quote
Modify the string transmitter program to detect simple transmission errors
using parity bits. That is, each eight-bit binary number produced during
encoding is extended with a parity bit, set to one if the number contains
an odd number of ones, and to zero otherwise. In turn, each resulting nine-
bit binary number consumed during decoding is checked to ensure that its
parity bit is correct, with the parity bit being discarded if this is the case,
and a parity error reported otherwise.

*Hint:*
The library function =error :: String → a= terminates evaluation and
displays the given string as an error message.

#+end_quote

* Test
#+begin_quote
Test your new string transmitter program from the previous exercise using
a faulty communication channel that forgets the first bit, which can be
modelled using the tail function on lists of bits.
#+end_quote
