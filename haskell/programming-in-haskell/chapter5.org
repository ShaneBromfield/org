#+BLOG: tony-blog
#+POSTID: 734
#+DATE: [2012-12-27 jeu. 23:45]
#+BLOG: tony-blog
#+TITLE: Programming in haskell - ch5 - Lists comprehension - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

* List comprehension
#+BEGIN_QUOTE
Using a list comprehension, give an expression that calculates the sum *1^2 + 2^2 + . . . 100^2* of the first one hundred integer squares.
#+END_QUOTE

#+begin_src text
let ss100 = sum [ x^2 | x <- [1..100]]
#+end_src
* *replicate*
#+BEGIN_QUOTE
In a similar way to the function *length*, show how the library function *replicate :: Int → a → [ a ]*
that produces a list of identical elements can be defined using a list comprehension.

For example:

> replicate 3 True

[True, True, True]
#+END_QUOTE

#+begin_src text
replicate :: Int -> a -> [a]
replicate n x = [x | _ <- [1..n]]
#+end_src

#+begin_example
*Ch5> replicate 10 'a'
"aaaaaaaaaa"
*Ch5> replicate 10 1
[1,1,1,1,1,1,1,1,1,1]
#+end_example
* *pyths*
#+BEGIN_QUOTE
A triple *(x, y, z)* of positive integers is pythagorean if *x^2 + y^2 = z^2*.

Using a list comprehension, define a function *pyths :: Int → [(Int, Int, Int)]* that
returns the list of all pythagorean triples whose components are at most a given limit.

For example:

> pyths 10

[(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]
#+END_QUOTE

* perfect numbers
#+BEGIN_QUOTE
A positive integer is perfect if it equals the sum of its factors, excluding the number itself.

Using a list comprehension and the function *factors*, define a function *perfects :: Int → [ Int ]*
that returns the list of all perfect numbers up to a given limit.

For example:

> perfects 500

[6, 28, 496]
#+END_QUOTE

* Comprehension
#+BEGIN_QUOTE
Show how the single comprehension *[(x, y) | x ← [1, 2, 3], y ← [4, 5, 6]]* with two generators can be re-expressed using two comprehensions with single generators.

*Hint:*
 make use of the library function *concat* and nest one comprehension within the other.
#+END_QUOTE

* *positions*
#+BEGIN_QUOTE
Redefine the function *positions* using the function *find*.
#+END_QUOTE

* scalarproduct
#+BEGIN_QUOTE
The scalar product of two lists of integers xs and ys of length n is given by the sum of the products of corresponding integers:
=sum i=0..n−1 (xsi ∗ ysi)=

In a similar manner to the function *chisqr*, show how a list comprehension can be used to define a function *scalarproduct :: [ Int ] → [ Int ] → Int*
 that returns the scalar product of two lists.

For example:

> scalarproduct [1, 2, 3] [4, 5, 6]

32
#+END_QUOTE

* Caesar cipher
#+BEGIN_QUOTE
Modify the Caesar cipher program to also handle upper-case letters.
#+END_QUOTE
