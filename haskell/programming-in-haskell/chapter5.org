#+BLOG: tony-blog
#+TITLE: Programming in haskell - ch5 b- Lists comprehension - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

* List comprehension
#+BEGIN_QUOTE
Using a list comprehension, give an expression that calculates the sum *1^2 + 2^2 + . . . 100^2* of the first one hundred integer squares.
#+END_QUOTE

* *replicate*
#+BEGIN_QUOTE
In a similar way to the function *length*, show how the library function *replicate :: Int → a → [ a ]*
that produces a list of identical elements can be defined using a list comprehension.

For example:
#+BEGIN_SRC text
> replicate 3 True
[True, True, True]
#+END_SRC
#+END_QUOTE

* *pyths*
#+BEGIN_QUOTE
A triple *(x, y, z)* of positive integers is pythagorean if *x^2 + y^2 = z^2*.

Using a list comprehension, define a function *pyths :: Int → [(Int, Int, Int)]* that
returns the list of all pythagorean triples whose components are at most a given limit.

For example:
#+BEGIN_SRC text
> pyths 10
[(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]
#+END_SRC

#+END_QUOTE

* perfect numbers
#+BEGIN_QUOTE
A positive integer is perfect if it equals the sum of its factors, excluding the number itself.

Using a list comprehension and the function *factors*, define a function *perfects :: Int → [ Int ]*
that returns the list of all perfect numbers up to a given limit.

For example:
#+BEGIN_SRC text
> perfects 500
[6, 28, 496]
#+END_SRC
#+END_QUOTE

* Comprehension
#+BEGIN_QUOTE
Show how the single comprehension *[(x, y) | x ← [1, 2, 3], y ← [4, 5, 6]]* with two generators can be re-expressed using two comprehensions with single generators.

*Hint:*
 make use of the library function *concat* and nest one comprehension within the other.
#+END_QUOTE

* *positions*
#+BEGIN_QUOTE
Redefine the function *positions* using the function *find*.
#+END_QUOTE

* scalarproduct
#+BEGIN_QUOTE
The scalar product of two lists of integers xs and ys of length n is given by the sum of the products of corresponding integers:
=sum i=0..n−1 (xsi ∗ ysi)=

In a similar manner to the function *chisqr*, show how a list comprehension can be used to define a function *scalarproduct :: [ Int ] → [ Int ] → Int*
 that returns the scalar product of two lists.

For example:
#+BEGIN_SRC text
> scalarproduct [1, 2, 3] [4, 5, 6]
32
#+END_SRC
#+END_QUOTE

* Caesar cipher
#+BEGIN_QUOTE
Modify the Caesar cipher program to also handle upper-case letters.
#+END_QUOTE
