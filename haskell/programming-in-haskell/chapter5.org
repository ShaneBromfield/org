#+BLOG: tony-blog
#+POSTID: 734
#+DATE: [2012-12-27 jeu. 23:45]
#+BLOG: tony-blog
#+TITLE: Programming in haskell - ch5 - Lists comprehension - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

* List comprehension
#+BEGIN_QUOTE
Using a list comprehension, give an expression that calculates the sum \\
 *1^2 + 2^2 + . . . 100^2*.
#+END_QUOTE

#+begin_src text
let ss100 = sum [ x^2 | x <- [1..100]]
#+end_src
* *replicate*
#+BEGIN_QUOTE
In a similar way to the function *length*, show how the library function \\
*replicate :: Int → a → [ a ]* that produces a list of identical elements can be defined using a list comprehension.

For example:
> replicate 3 True

[True, True, True]
#+END_QUOTE

#+begin_src text
replicate :: Int -> a -> [a]
replicate n x = [x | _ <- [1..n]]
#+end_src

#+begin_example
*Ch5> replicate 10 'a'
"aaaaaaaaaa"
*Ch5> replicate 10 1
[1,1,1,1,1,1,1,1,1,1]
#+end_example
* *pyths*
#+BEGIN_QUOTE
A triple *(x, y, z)* of positive integers is pythagorean if *x^2 + y^2 = z^2*.

Using a list comprehension, define a function *pyths :: Int → [(Int, Int, Int)]* that
returns the list of all pythagorean triples whose components are at most a given limit.

For example:
> pyths 10

[(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]
#+END_QUOTE

We search all the triplets (x, y, z) such as (x,y,z) in [1..n]^3 and x^2+y^2=z^2:

#+begin_src text
pyths :: Int -> [(Int, Int, Int)]
pyths n = [(x, y, z) | x <- m,
                       y <- m,
                       z <- m,
                       x^2 + y^2 == z^2 ]
          where m = [1..n]
#+end_src

* perfect numbers
#+BEGIN_QUOTE
A positive integer is perfect if it equals the sum of its factors, excluding the number itself.

Using a list comprehension and the function *factors*, define a function \\
*perfects :: Int → [ Int ]* that returns the list of all perfect numbers up to a given limit.

For example:
> perfects 500

[6, 28, 496]
#+END_QUOTE

We are first given the definition for a perfect number so we implement it:
#+begin_src text
perfect :: Int -> Bool
perfect m = sum [ y | y <- factors m, y /= m ] == m
#+end_src

*Note*
We can iterate over the *perfect* implementation and change it using the *init* function (drops the last element of a list):
#+begin_src text
perfect :: Int -> Bool
perfect m = sum (init (factors m)) == m
#+end_src

*Note*
- The implementation is litteraly the definition.
- we have the *factors* function that already computes the factors of a number, so we reuse it.

We can now define the main function using the previous *perfect* function:
#+begin_src text
perfects :: Int -> [Int]
perfects n = [x | x <- [1..n], perfect x]
#+end_src

* Comprehension
#+BEGIN_QUOTE
Show how the single comprehension *[(x, y) | x ← [1, 2, 3], y ← [4, 5, 6]]* with two
generators can be re-expressed using two comprehensions with single generators.

*Hint:*
Make use of the library function *concat* and nest one comprehension within the other.
#+END_QUOTE

Apparently, from the *hint*, is possible to nest the list comprehensions.

We will go one step at a time, first nesting:
#+begin_src text
Prelude> [[(x,y) | x <- [1,2,3]] | y <- [4,5,6]]
[[(1,4),(2,4),(3,4)],[(1,5),(2,5),(3,5)],[(1,6),(2,6),(3,6)]]
#+end_src

Indeed, now if we use *concat*, this will give us what we want:

#+begin_src text
Prelude> concat [[(x,y) | x <- [1,2,3]] | y <- [4,5,6]]
[(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(1,6),(2,6),(3,6)]
#+end_src

which is equal to the first result if we do not consider the list order:
#+begin_src text
Prelude> [(x, y) | x <- [1, 2, 3], y <- [4, 5, 6]]
[(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]

#+end_src

* *positions*
#+BEGIN_QUOTE
Redefine the function *positions* using the function *find*.
#+END_QUOTE

* scalarproduct
#+BEGIN_QUOTE
The scalar product of two lists of integers xs and ys of length n is given by the sum of the products of corresponding integers:
=sum i=0..n−1 (xsi ∗ ysi)=

In a similar manner to the function *chisqr*, show how a list comprehension can be used to define a function *scalarproduct :: [ Int ] → [ Int ] → Int*
 that returns the scalar product of two lists.

For example:

> scalarproduct [1, 2, 3] [4, 5, 6]

32
#+END_QUOTE

* Caesar cipher
#+BEGIN_QUOTE
Modify the Caesar cipher program to also handle upper-case letters.
#+END_QUOTE
