#+BLOG: tony-blog
#+TITLE: Programming in haskell - ch5 - Lists comprehension - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

Exercises on the chapter 5 of the books.
We encounter :
- conditional expressions
- guarded equations
- pattern matching (tuple, list, integer)
- lambda expressions

* Halve
#+BEGIN_QUOTE
Using library functions, define a function =halve :: [a] → ([a], [a])= that splits an even-lengthed list into two halves.

For example:

> halve [1, 2, 3, 4, 5, 6]

([1, 2, 3], [4, 5, 6])
#+END_QUOTE

The function *splitAt* already provides the means to split one list from a given position.
Here our position is the half of the length of the list, which gives:

#+BEGIN_SRC text
halve :: [a] -> ([a], [a])
halve xs = splitAt (length xs `div` 2) xs
#+END_SRC

Executing in the repl, we obtain:
#+BEGIN_SRC text
*Ch4> halve [1, 2, 3, 4, 5, 6]
([1,2,3],[4,5,6])
#+END_SRC

* safetail
#+BEGIN_QUOTE
Consider a function =safetail :: [a] → [a]= that behaves as the library function *tail*, except that safetail maps the empty list to itself, whereas *tail* produces an error in this case.

Define *safetail* using:
- a conditional expression
- guarded equations
- pattern matching

*Hint:* make use of the library function *null*.
#+END_QUOTE

** conditional expression

We need the conditional to discriminate between the empty list (=null xs=) and the non empty list.
If we are not in the empty list case, we can drop the *head* of the list to obtain the *tail* of list

Thus giving:

#+BEGIN_SRC text
safetail1 :: [a] -> [a]
safetail1 xs = if null xs then [] else drop 1 xs
#+END_SRC

Example:
#+BEGIN_SRC text
*Ch4> safetail1 []
[]
*Ch4> safetail1 [1,2,3]
[2,3]
#+END_SRC

** guarded equations

Same explanation as before:

#+BEGIN_SRC text
safetail2 :: [a] -> [a]
safetail2 xs | null xs   = []
             | otherwise = drop 1 xs
#+END_SRC

Example:
#+BEGIN_SRC text
*Ch4> safetail2 []
[]
*Ch4> safetail2 [3,2,1]
[2,1]

#+END_SRC
** pattern matching
* logical disjunction
#+BEGIN_QUOTE
In a similar way to *∧*, show how the logical disjunction operator *∨* can be defined in four different ways using pattern matching.
#+END_QUOTE

* conditional expression
#+BEGIN_QUOTE
Redefine the following version of the conjunction operator using conditional expressions rather than pattern matching:

True ∧ True = True

_ ∧ _       = False
#+END_QUOTE

* conditional expression 2
#+BEGIN_QUOTE
Do the same for the following version, and note the difference in the number of conditional expressions required:

True ∧ b  = b

False ∧ _ = False
#+END_QUOTE

* Curried function and lambda expression
#+BEGIN_QUOTE
Show how the curried function definition =mult x y z = x ∗ y ∗ z= can be understood in terms of lambda expressions.
#+END_QUOTE
