#+BLOG: tony-blog
#+POSTID: 903
#+DATE: [2013-01-05 sam. 15:53]
#+TITLE: Programming in haskell - ch7 - Higher-order functions 2/2
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

For the first exercises, [[http://adumont.fr/blog/pih-ch7-higher-order-functions-12/][see this post]].

* curry/uncurry
#+begin_quote
Without looking at the standard prelude, define the higher-order library function *curry* that converts a function on pairs into a curried function, and, conversely, the function *uncurry* that converts a curried function with two arguments into a function on pairs.

*Hint:*
First write down the types of the two functions.
#+end_quote

** curry
First the type:

A function that takes a pair as parameter and output something is typed: =((a,b) -> c)=
A currified function that takes 2 parameters and output something is typed: =a -> b -> c=
Thus the final type:
#+begin_src haskell
curry :: ((a,b) -> c) -> a -> b -> c
#+end_src

Now the definition:
#+begin_src haskell
curry :: ((a,b) -> c) -> a -> b -> c
curry f = \x -> \y -> f (x,y)
#+end_src

Simpler
#+begin_src haskell
curry :: ((a,b) -> c) -> a -> b -> c
curry f x y = f (x,y)
#+end_src

Examples:

We need a function that takes a pair as parameter:
#+begin_src haskell
add :: Num a => (a,a) -> a
add (x,y) = x + y
#+end_src

Here is how is used the function =add=:
#+begin_src haskell
*Ch7_2> add (1,2)
3
#+end_src

Given that, a simple scenario to currify =add= is:
#+begin_src haskell
*Ch7_2> (curry add) 1 2
3
*Ch7_2> ((curry add) 1) 2
3
#+end_src

** uncurry
Conversely, the uncurrified function's type:
#+begin_src haskell
uncurry :: a -> b -> c -> (a, b) -> c
#+end_src

Now the definition:
#+begin_src haskell
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f = \ (x, y) -> (f x y)
#+end_src

Simpler
#+begin_src haskell
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y
#+end_src


#+begin_src haskell
*Ch7_2> add (1,2)
3
*Ch7_2> (curry add) 1 2
3
*Ch7_2> uncurry (curry add) (1,2)
3
#+end_src

* unfold
#+begin_quote
A higher-order function *unfold* that encapsulates a simple pattern of recursion for producing a list can be defined as follows:
#+begin_src haskell
unfold p h t x | p x = []
               | otherwise = h x : unfold p h t (t x)
#+end_src

That is, the function =unfold p h t= produces the empty list if the predicate =p= is true of the argument, and otherwise produces a non-empty list by applying the function =h= to give the head, and the function =t= to generate another argument that is recursively processed in the same way to produce the tail of the list.

For example, the function *int2bin* can be rewritten more compactly using *unfold* as follows:
#+begin_src haskell
int2bin = unfold (== 0) (`mod` 2) (`div` 2)
#+end_src

Redefine the functions *chop8*, *map f* and *iterate f* using unfold.
#+end_quote

** chop8
/Split a bits list into a list of 8-bits list./

Recall the definition of the chop8 function:
#+begin_src haskell
chop8 :: [Bit] -> [[Bit]]
chop8 [] = []
chop8 bits = take 8 bits : (chop8 (drop 8 bits))
#+end_src

Here is the 3 functions needed:
- predicate: check if a list is empty, we can use the =null= function for that
- head: we take 8 bits
- tail: we drop 8 bits

Using =unfold=:
#+begin_src haskell
chop8 :: [Bit] -> [[Bit]]
chop8 = unfold null (take 8) (drop 8)
#+end_src
** map f
/Map a function =f= to a list/

Recall the recursive definition of =map=:

#+begin_src haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x:(map f xs)
#+end_src

From this we deduce the 3 needed functions:
- predicate: check if a list is empty
- head: =f . head= (first extracting head, then applying =f= to it)
- tail: extracting the tail, =tail=.

#+begin_src haskell
map :: (a -> b) -> [a] -> [b]
map f = unfold null (f . head) tail
#+end_src

#+begin_src haskell
*Ch7_2> map (+1) [1,2,4]
[2,3,5]
*Ch7_2> map even [1,2,4]
[False,True,True]
*Ch7_2> map int2bin [1,2,4,8,16]
[[1],[0,1],[0,0,1],[0,0,0,1],[0,0,0,0,1]]
#+end_src

** iterate f
/lazy and infinite iteration over f=/

A recursive definition of =iterate= can be:

#+begin_src haskell
iterate :: (a -> a) -> a -> [a]
iterate f x = x : iterate f (f x)
#+end_src

Example:
#+begin_src haskell
*Ch7_2> take 10 (iter (+1) 10)
[10,11,12,13,14,15,16,17,18,19]
#+end_src

Given this, here are the needed functions:
- predicate: we want an infinite function, so a function that takes a parameter and returns False, =(\ _ -> False)= is a good default
- head: as we always return false, we'll never pass here, so identity is a good shot
- tail: at last, it's where all the work is done, we want =f= to be applied

#+begin_src haskell
iterate :: (a -> a) -> a -> [a]
iterate f = unfold (\ _ -> False) id f
#+end_src

*Note*
I discovered the function =const=
So we can replace this definition by this one:
#+begin_src haskell
iterate :: (a -> a) -> a -> [a]
iterate f = unfold (const False) id f
#+end_src

Example:
#+begin_src haskell
*Ch7_2> take 10 (iterate (+2) 0)
[0,2,4,6,8,10,12,14,16,18]
#+end_src

* transmitter
#+begin_quote
Modify the string transmitter program to detect simple transmission errors using parity bits. That is, each eight-bit binary number produced during encoding is extended with a parity bit, set to one if the number contains an odd number of ones, and to zero otherwise.
In turn, each resulting nine-bit binary number consumed during decoding is checked to ensure that its parity bit is correct, with the parity bit being discarded if this is the case, and a parity error reported otherwise.

*Hint:*
The library function =error :: String â†’ a= terminates evaluation and displays the given string as an error message.
#+end_quote

Recall the existing functions:
#+begin_src haskell
int2bin :: Int -> [Bit]
int2bin 0 = []
int2bin n = int2bin (n `div` 2) ++ [n `mod` 2]
#+end_src

** parbit
We need the =parbit= function which add the parity bit at the ninth position:

#+begin_src haskell
parbit :: [Bit] -> [Bit]
parbit xs | even (sum xs) = xs ++ [0] -- even number of ones
          | otherwise     = xs ++ [1] -- odd number of ones
#+end_src

Example:
#+begin_src haskell
*Ch7_2> parbit [1,1,0]
[1,1,0,0]
*Ch7_2> parbit [1,1,1]
[1,1,1,1]
#+end_src

** encode
Now we need to add in the function the adding of the parity bit.
After we created the 8 bits portion seems a good idea, so here we go:
#+begin_src haskell
encode :: String -> [Bit]
encode = concat . map (parbit . make8 . int2bin . C.ord)
#+end_src

** chop9
Now we need to be able to chop bits by bucket of 9:

Using =unfold=, this goes quite fast:
#+begin_src haskell
chop9 :: [Bit] -> [[Bit]]
chop9 = unfold null (take 9) (drop 9)
#+end_src

Example:
#+begin_src haskell
*Ch7_2> chop9 (encode "haskell")
[[0,1,1,0,1,0,0,0,1],[0,1,1,0,0,0,0,1,1],[0,1,1,1,0,0,1,1,1],[0,1,1,0,1,0,1,1,1],[0,1,1,0,0,1,0,1,0],[0,1,1,0,1,1,0,0,0],[0,1,1,0,1,1,0,0,0]]
#+end_src

** checkParbit

I take 8 bits, compute the parity bit and check with the all list, if this matches, then I return the 8th bits, otherwise, i raise an error:
#+begin_src haskell
checkParbit :: [Bit] -> [Bit]
checkParbit xs | (parbit (take 8 xs) == xs) = (take 8 xs)
               | otherwise = error "Not ok"
#+end_src

Example:
#+begin_src haskell
*Ch7_2> checkParbit (encode "a")
[0,1,0,0,0,0,1,1]
*Ch7_2> checkParbit [0,1,0,0,0,0,1,0]
*** Exception: Not ok
#+end_src

*** decode
At last, we can update the decode phase.
We must first chop by 9 bits the list of bits we receive.
Then checking the parity bits, then the rest:

#+begin_src haskell
decode :: [Bit] -> String
decode = map (C.chr . bin2int . checkParbit) . chop9
#+end_src

* Test
#+begin_quote
Test your new string transmitter program from the previous exercise using a faulty communication channel that forgets the first bit, which can be modelled using the tail function on lists of bits.
#+end_quote
** Without errors
Recall the transmit function:

#+begin_src haskell
channel :: a -> a
channel = id

transmit :: String -> String
transmit = decode . channel . encode
#+end_src

Thus, everything works ok:
#+begin_src haskell
*Ch7_2> transmit "haskell is great"
"haskell is great"
#+end_src

** Errors
The transmit function does not need to change. However, the channel one does.
As the problem states, we can for example use =tail= for this:

#+begin_src haskell
channel :: a -> a
channel = tail
#+end_src

Then all hell breaks loose:
#+begin_src haskell
*Ch7_2> transmit "haskell is great"
"\209\195\231\215\202\216\216A\210\231A\207\228\202\195*** Exception: Not ok
#+end_src
