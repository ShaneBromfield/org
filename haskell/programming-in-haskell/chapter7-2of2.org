#+BLOG: tony-blog
#+POSTID: 903
#+DATE: [2013-01-05 sam. 15:53]
#+TITLE: Programming in haskell - ch7 - Higher-order functions 2/2
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

For the first exercises, [[http://adumont.fr/blog/pih-ch7-higher-order-functions-12/][see this post]].

* curry/uncurry
#+begin_quote
Without looking at the standard prelude, define the higher-order library function *curry* that converts a function on pairs into a curried function, and, conversely, the function *uncurry* that converts a curried function with two arguments into a function on pairs.

*Hint:*
First write down the types of the two functions.
#+end_quote

** curry
First the type:

A function that takes a pair as parameter and output something is typed: =((a,b) -> c)=
A currified function that takes 2 parameters and output something is typed: =a -> b -> c=
Thus the final type:
#+begin_src haskell
curry :: ((a,b) -> c) -> a -> b -> c
#+end_src

Now the definition:
#+begin_src haskell
curry :: ((a,b) -> c) -> a -> b -> c
curry f = \x -> \y -> f (x,y)
#+end_src

Simpler
#+begin_src haskell
curry :: ((a,b) -> c) -> a -> b -> c
curry f x y = f (x,y)
#+end_src

Examples:

We need a function that takes a pair as parameter:
#+begin_src haskell
add :: Num a => (a,a) -> a
add (x,y) = x + y
#+end_src

Here is how is used the function =add=:
#+begin_src haskell
*Ch7_2> add (1,2)
3
#+end_src

Given that, a simple scenario to currify =add= is:
#+begin_src haskell
*Ch7_2> (curry add) 1 2
3
*Ch7_2> ((curry add) 1) 2
3
#+end_src

** uncurry
Conversely, the uncurrified function's type:
#+begin_src haskell
uncurry :: a -> b -> c -> (a, b) -> c
#+end_src

Now the definition:
#+begin_src haskell
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f = \ (x, y) -> (f x y)
#+end_src

Simpler
#+begin_src haskell
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y
#+end_src


#+begin_src haskell
*Ch7_2> add (1,2)
3
*Ch7_2> (curry add) 1 2
3
*Ch7_2> uncurry (curry add) (1,2)
3
#+end_src

* unfold
#+begin_quote
A higher-order function *unfold* that encapsulates a simple pattern of recursion for producing a list can be defined as follows:
#+begin_src haskell
unfold p h t x | p x = []
               | otherwise = h x : unfold p h t (t x)
#+end_src

That is, the function =unfold p h t= produces the empty list if the predicate =p= is true of the argument, and otherwise produces a non-empty list by applying the function =h= to give the head, and the function =t= to generate another argument that is recursively processed in the same way to produce the tail of the list.

For example, the function *int2bin* can be rewritten more compactly using *unfold* as follows:
#+begin_src haskell
int2bin = unfold (== 0) (`mod` 2) (`div` 2)
#+end_src

Redefine the functions *chop8*, *map f* and *iterate f* using unfold.
#+end_quote

** chop8
/Split a bits list into a list of 8-bits list./

Recall the definition of the chop8 function:
#+begin_src haskell
chop8 :: [Bit] -> [[Bit]]
chop8 [] = []
chop8 bits = take 8 bits : (chop8 (drop 8 bits))
#+end_src

Here is the 3 functions needed:
- predicate: check if a list is empty, we can use the =null= function for that
- head: we take 8 bits
- tail: we drop 8 bits

Using =unfold=:
#+begin_src haskell
chop8 :: [Bit] -> [[Bit]]
chop8 = unfold null (take 8) (drop 8)
#+end_src
** map f
/Map a function =f= to a list/

Recall the recursive definition of =map=:

#+begin_src haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x:(map f xs)
#+end_src

From this we deduce the 3 needed functions:
- predicate: check if a list is empty
- head: =f . head= (first extracting head, then applying =f= to it)
- tail: extracting the tail, =tail=.

#+begin_src haskell
map :: (a -> b) -> [a] -> [b]
map f = unfold null (f . head) tail
#+end_src

#+begin_src haskell
*Ch7_2> map (+1) [1,2,4]
[2,3,5]
*Ch7_2> map even [1,2,4]
[False,True,True]
*Ch7_2> map int2bin [1,2,4,8,16]
[[1],[0,1],[0,0,1],[0,0,0,1],[0,0,0,0,1]]
#+end_src

** iterate f
/lazy iteration over f: =\ x -> (f (f (f (f x))))...=/

* transmitter
#+begin_quote
Modify the string transmitter program to detect simple transmission errors using parity bits. That is, each eight-bit binary number produced during encoding is extended with a parity bit, set to one if the number contains an odd number of ones, and to zero otherwise.
In turn, each resulting nine-bit binary number consumed during decoding is checked to ensure that its parity bit is correct, with the parity bit being discarded if this is the case, and a parity error reported otherwise.

*Hint:*
The library function =error :: String â†’ a= terminates evaluation and displays the given string as an error message.

#+end_quote

* Test
#+begin_quote
Test your new string transmitter program from the previous exercise using a faulty communication channel that forgets the first bit, which can be modelled using the tail function on lists of bits.
#+end_quote
