#+BLOG: tony-blog
#+TITLE: Programming in haskell - ch6 - Recursive functions - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars

* Exponentiation
#+begin_quote
Define the exponentiation operator ↑ for non-negative integers using the
same pattern of recursion as the multiplication operator =∗=, and show how *2 ↑ 3* is evaluated using your definition.
#+end_quote

#+begin_src text
(^) :: Int -> Int -> Int
_ ^ 0 = 1
x ^ n = x * (x ^ (n-1))
#+end_src

#+begin_src text
2 ^ 3 = 2 * (2 ^ 2)
      = 2 * 2 * (2 ^ 1)
      = 2 * 2 * 2 * (2 ^ 0)
      = 2 * 2 * 2 * 1
      = 8
#+end_src

* evaluated
#+begin_quote
Using the definitions given in this chapter, show how *length [1, 2, 3]*,
*drop 3 [1, 2, 3, 4, 5]*, and *init [1, 2, 3]* are evaluated.
#+end_quote

** length
Given the definition:
#+begin_src text
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs
#+end_src

#+begin_src text
length [1,2,3] = 1 + length [2,3]
               = 1 + 1 + length [3]
               = 1 + 1 + 1 + length []
               = 1 + 1 + 1 + 0
               = 3
#+end_src

** drop
Given the definition:
#+begin_src text
drop :: Int -> [a] -> [a]
drop 0 ys = ys
drop _ [] = []
drop n (_:ys) = drop (n-1) ys
#+end_src

#+begin_src text
drop 3 [1,2,3,4,5] = drop 2 [2,3,4,5]
                   = drop 1 [3,4,5]
                   = drop 0 [4,5]
                   = [4,5]
#+end_src

** init
Given the definition:
#+begin_src text
init :: [a] -> [a]
init [_] = []
init (x:xs) = x:(init xs)
#+end_src

#+begin_src text
init [1,2,3] = 1:(init [2,3])
             = 1:2:(init [3])
             = 1:2:[]
             = [1,2]
#+end_src
* functions
#+begin_quote
Without looking at the definitions from the standard prelude, define the
following library functions using recursion:
-- and
-- concat
-- replicate
-- (!!)
-- elem

*Note:* most of these functions are in fact defined in the prelude using other
library functions, rather than using explicit recursion.
#+end_quote

** *and*
#+begin_quote
-- Decide if all logical values in a list are True: =and :: [Bool] → Bool=
#+end_quote

#+begin_src text
and :: [Bool] -> Bool
and [] = True
and (x:xs) = x && (and xs)
#+end_src

Example:
#+begin_src text
*Ch6> and [True, True, True]
True
*Ch6> and [True, False, True]
False
#+end_src

** *concat*
#+begin_quote
-- Concatenate a list of lists: =concat :: [[a] ] → [a]=
#+end_quote

#+begin_src text
concat :: [[a]] -> [a]
concat [xs] = xs
concat (xs:xxs) = xs ++ (concat xxs)
#+end_src

Example:
#+begin_src text
*Ch6> concat [[1..10], [2,4], [20..25]]
[1,2,3,4,5,6,7,8,9,10,2,4,20,21,22,23,24,25]
#+end_src
** *replicate*
#+begin_quote
-- Produce a list with n identical elements: =replicate :: Int → a → [a]= \\
#+end_quote

#+begin_src text
replicate :: Int -> a -> [a]
replicate 0 _ = []
replicate n x = x:(replicate (n-1) x)
#+end_src

Example:
#+begin_src text
*Ch6> replicate 10 'a'
"aaaaaaaaaa"
*Ch6> replicate 5 9
[9,9,9,9,9]
#+end_src
** *(!!)*
#+begin_quote
-- Select the n^th element of a list: =(!!) :: [a] → Int → a= \\
#+end_quote
** *elem*
#+begin_quote
-- Decide if a value is an element of a list: =elem :: Eq a ⇒ a → [a] → Bool= \\
#+end_quote

* merge
#+begin_quote
Define a recursive function =merge :: Ord a ⇒ [a] → [a] → [a]= that
merges two sorted lists to give a single sorted list.

For example:

> merge [2, 5, 6] [1, 3, 4]
[1, 2, 3, 4, 5, 6]

*Note:* your definition should not use other functions on sorted lists such as
*insert* or *isort*, but should be defined using explicit recursion.
#+end_quote
* msort
#+begin_quote
Using *merge*, define a recursive function =msort :: Ord a ⇒ [a] → [a]= that
implements merge sort, in which the empty list and singleton lists are already
sorted, and any other list is sorted by merging together the two lists that
result from sorting the two halves of the list separately.

*Hint:*
 first define a function =halve :: [a] → [([a], [a])]= that splits a list into
two halves whose lengths differ by at most one.
#+end_quote
* sum
#+begin_quote
Using the five-step process, define the library functions that calculate the
sum of a list of numbers, take a given number of elements from the start of
a list, and select the last element of a non-empty list.
#+end_quote
