#+BLOG: tony-blog
#+POSTID: 654
#+DATE: [2012-12-24 Mon 20:35]
#+BLOG: tony-blog
#+TITLE: Programming in haskell - Ch3 - Types and classes - exercises
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Learning haskell and solving problems using reasoning and 'repl'ing
#+STARTUP: indent
#+STARTUP: hidestars odd

* Types of values
#+BEGIN_QUOTE
What are the types of the following values?
- [’a', 'b', 'c']
- ('a', 'b', 'c')
- [(False, 'O'), (True, '1')]
- ([False, True ], ['0', '1'])
- [tail , init, reverse ]
#+END_QUOTE

|------------------------------+--------------------|
| Values                       | Types              |
|------------------------------+--------------------|
| ['a', 'b', 'c']              | [Char]             |
| ('a', 'b', 'c')              | (Char, Char, Char) |
| [(False, 'O'), (True, '1')]  | [(Bool, Char)]     |
| ([False, True ], ['0', '1']) | ([Bool], [Char])   |
| [tail , init, reverse]       | [[a] -> [a]]       |
|------------------------------+--------------------|

* Types of functions
#+BEGIN_QUOTE
What are the types of the following functions?
- second xs = head (tail xs)
- swap (x , y) = (y, x)
- pair x y = (x , y)
- double x = x ∗ 2
- palindrome xs = reverse xs == xs
- twice f x = f (f x)

*Hint* take care to include the necessary class constraints if the functions are
defined using overloaded operators.
#+END_QUOTE

|----------------------------------+-----------------------------------|
| Functions                        | Types                             |
|----------------------------------+-----------------------------------|
| second xs = head (tail xs)       | second :: [a] -> a                |
| swap (x , y) = (y, x)            | swap :: (a,a) -> (a,a)            |
| pair x y = (x , y)               | pair :: a -> a -> (a, a)          |
| double x = x ∗ 2                 | double :: Num a => a -> a         |
| palindrome xs = reverse xs == xs | palindrome :: Eq a => [a] -> Bool |
| twice f x = f (f x)              | twice :: (a -> a) -> a -> a       |
|----------------------------------+-----------------------------------|

* Check with HUG
#+BEGIN_QUOTE
Check your answers to the preceding two questions using Hugs.
#+END_QUOTE

|----------------------------------+-----------------------------------+------------|
| Functions                        | Types                             | Result HUG |
|----------------------------------+-----------------------------------+------------|
| second xs = head (tail xs)       | second :: [a] -> a                | OK         |
| swap (x , y) = (y, x)            | swap :: (a,a) -> (a,a)            | OK         |
| pair x y = (x , y)               | pair :: a -> a -> (a, a)          | OK         |
| double x = x ∗ 2                 | double :: Num a => a -> a         | OK         |
| palindrome xs = reverse xs == xs | palindrome :: Eq a => [a] -> Bool | OK         |
| twice f x = f (f x)              | twice :: (a -> a) -> a -> a       | OK         |
|----------------------------------+-----------------------------------+------------|

* Questions
#+BEGIN_QUOTE
Why is it not feasible in general for function types to be instances of the Eq class?
#+END_QUOTE

#+BEGIN_QUOTE
When is it feasible? Hint: two functions of the same type are equal if
they always return equal results for equal arguments.
#+END_QUOTE
