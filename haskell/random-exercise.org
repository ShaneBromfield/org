#+BLOG: tony-blog
#+TITLE: Some random exercise in haskell
#+AUTHOR: Massyl Nait-Mouloud, Antoine R. Dumont
#+OPTIONS:
#+TAGS: haskell, exercises, functional-programming
#+CATEGORY: haskell, exercises, functional-programming
#+DESCRIPTION: Some random exercises
#+STARTUP: indent
#+STARTUP: hidestars

A friend of mine asks me to solve a simple exercise in haskell.
As i made a mistake in solving it the first time (due to the missed unicity, I considered posting it here).

Here is the revised problem:

#+begin_quote
Find all the unique couple *(a,b)* such that *a*b = n*

*Note*
As the multiplication is commutative, we consider : *for any a, b, (a,b) == (b,a)*
#+end_quote

Naive first:
#+begin_src text
couple :: Int -> [(Int,Int)]
couple n = [(a,b) | a <- [2..n], b <- [1..a], a * b == n]
#+end_src

To avoid making duplicates, the trick is to consider the input as a kind of pyramid instead of square.
#+begin_quote
for *n = 9* \\

a in *2 3 4 5 6 7 8 9*

b in:\\
*1 2* +3 4 5 6 7 8 9+ \\
*1 2 3* +4 5 6 7 8 9+ \\
*1 2 3 4* +5 6 7 8 9+ \\
*1 2 3 4 5* +6 7 8 9+ \\
*1 2 3 4 5 6* +7 8 9+ \\
*1 2 3 4 5 6 7* +8 9+ \\
*1 2 3 4 5 6 7 8* +9+ \\
*1 2 3 4 5 6 7 8 9*

#+end_quote
