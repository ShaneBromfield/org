#+title: Matasano 1-8 exercises
#+author: Antoine R. Dumont

Hi, here are my solutions for the first batch of 8 problems.
Language: Clojure

I'm permitting myself to send you this html-formatted email for you to better understand the snippet of code (cf. attachments if your mail reader does not render it or the org-mode file for emacs).
You will see in this email the upper layer code and the integration tests formalizing the examples you gave me.

* Namespace
Firstly the namespace which loads the needed api:

#+begin_src clojure
(ns crypto.c18
  (:require [midje.sweet    :as m]
            [crypto
             [file          :as file]
             [hex           :as hex]
             [base64        :as b64]
             [aes           :as aes]
             [byte          :as byte]
             [frequency     :as frequency]
             [block         :as block]]
            [clojure.string :as string]))
#+end_src
* Exercises
** 1
For this exercise, I bootstraped the basis:
- hex encoding to bytes
- bytes to binary
- binary to base64
- base64 to binary
- binary to bytes
- bytes to hex
- ascii to hex
- hex to ascii

(A little more than needed)
#+begin_src clojure
;; c1

(m/fact
  (hex/>b64 "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d")
  => "SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t")

(m/fact
  (b64/>hex "SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t")
  => "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d")
#+end_src

** 2

In this one, I created the xor function to deal with bitwise xor. And reused a lot of previous functions.

#+begin_src clojure
;; c2

(defn xor
  "Given a hex msg and a hex key, encode the msg with the key using xor"
  [msg key]
  (->> [msg key]
       (map hex/>bytes)
       (apply xor/xor)
       byte/>hex))

(m/fact
  (xor "1c0111001f010100061a024b53535009181c" "686974207468652062756c6c277320657965") => "746865206b696420646f6e277420706c6179"
  (xor "746865206b696420646f6e277420706c6179" "686974207468652062756c6c277320657965") => "1c0111001f010100061a024b53535009181c")

#+end_src

** 3

I created the brute-force function which scan all the potential one-key from 0 to 255 characters and then compute a frequency analysis on each xor result with such key.
The frequency analysis with the minimal difference is taken as the optimal result.

The tweak was done on the frequency table to add the space character with a little frequence superior of the \e or \E character.

#+begin_src clojure
;; c3

(def brute-force (comp xor/decrypt-brute-force hex/>bytes))

(m/fact
  (brute-force "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736")
  => ["X" "Cooking MC's like a pound of bacon"])
#+end_src

** 4
For this one, I am brutal.
I execute the brute force function from the previous exercise for each line in the file.
Then we filter the result which seems to be english.

It's slow.

#+begin_src clojure
;; c4

(defn compute
  "Compute from a list of words"
  [words]
  (->> words
       (map (comp
             (fn [w] [w (xor/decrypt-brute-force w)])
             hex/>bytes))
       (filter (fn [[_ [_ decrypted-sentence] :as all]]
                 (char/sentence? decrypted-sentence)))))

(defn compute-encrypted-words
  [filepath]
  (-> filepath
      file/ld
      compute))

(m/fact :future-fact->avoid-the-long-time-computation-just-change-future-fact-in>fact
  (compute-encrypted-words "./resources/encrypted-words")
  => [[[123 90 66 21 65 93 84 65 21 65 93 80 21 69 84 71 65 76 21 92 70 21 95 64 88 69 92 91 82 63] ["5" "Now that the party is jumping\n"]]])
#+end_src

** 5
I already created some basic encrypt/decrypt functions for testing the previous exercises.
So here I reuse and add some basic function adding the transcoding layer (byte to hex to check the stuff you gave as example).

#+begin_src clojure
;; c5

(defn encrypt "Encrypt the ascii msg using the ascii key and return the result into hexadecimal."
  [m]
  (-> m
      xor/encrypt
      byte/>hex))

(defn decrypt "Decrypt the hexadecimal message using the ascii key and return the ascii message"
  [{:keys [key msg]}]
  (-> {:key key :msg (hex/>bytes msg)}
      xor/decrypt
      byte/>ascii))

(m/fact
  (encrypt {:key "ICE"
            :msg "Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal"})
  => "0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f"
  (decrypt {:key "ICE"
            :msg "0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f"})
  => "Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal")
#+end_src

** 6

This one, I had difficulties.
I sent you multiple emails to ask for clarifications about some points and never had any answer.
I finally used another way to compute the keysize (based on frequency).
I shifted the text and xor it against itself then computed the character frequencies. Those below 0.6 were multiple of keysize and else considered noise.
Then computing the gcd of all the multiple successfully computed previously gave me the key of the text (29).
From this on, I computed (as explained) blocks of characters encoded with the same key character and brute force each characters of the keys (as one-key xor encrypted), revealing the key.
Then deciphered the text.

#+begin_src clojure
;; c6

(defn break-repeating-key-xor
  "Given a byte input encoded, break the key and return the decrypted message"
  [input]
  (xor/decrypt {:key (-> input key/compute-key ascii/>bytes)
                :msg input}))

(defn break-repeating-key-xor-in-b64-encoded
  [filepath]
  (-> filepath
      file/ld-simple
      b64/>bytes
      break-repeating-key-xor))

(m/fact
  (break-repeating-key-xor-in-b64-encoded "./resources/base64-encoded")
  => "I'm back and I'm ringin' the bell \nA rockin' on the mike while the fly girls yell \nIn ecstasy in the back of me \nWell that's my DJ Deshay cuttin' all them Z's \nHittin' hard and the girlies goin' crazy \nVanilla's on the mike, man I'm not lazy. \n\nI'm lettin' my drug kick in \nIt controls my mouth and I begin \nTo just let it flow, let my concepts go \nMy posse's to the side yellin', Go Vanilla Go! \n\nSmooth 'cause that's the way I will be \nAnd if you don't give a damn, then \nWhy you starin' at me \nSo get off 'cause I control the stage \nThere's no dissin' allowed \nI'm in my own phase \nThe girlies sa y they love me and that is ok \nAnd I can dance better than any kid n' play \n\nStage 2 -- Yea the one ya' wanna listen to \nIt's off my head so let the beat play through \nSo I can funk it up and make it sound good \n1-2-3 Yo -- Knock on some wood \nFor good luck, I like my rhymes atrocious \nSupercalafragilisticexpialidocious \nI'm an effect and that you can bet \nI can take a fly girl and make her wet. \n\nI'm like Samson -- Samson to Delilah \nThere's no denyin', You can try to hang \nBut you'll keep tryin' to get my style \nOver and over, practice makes perfect \nBut not if you're a loafer. \n\nYou'll get nowhere, no place, no time, no girls \nSoon -- Oh my God, homebody, you probably eat \nSpaghetti with a spoon! Come on and say it! \n\nVIP. Vanilla Ice yep, yep, I'm comin' hard like a rhino \nIntoxicating so you stagger like a wino \nSo punks stop trying and girl stop cryin' \nVanilla Ice is sellin' and you people are buyin' \n'Cause why the freaks are jockin' like Crazy Glue \nMovin' and groovin' trying to sing along \nAll through the ghetto groovin' this here song \nNow you're amazed by the VIP posse. \n\nSteppin' so hard like a German Nazi \nStartled by the bases hittin' ground \nThere's no trippin' on mine, I'm just gettin' down \nSparkamatic, I'm hangin' tight like a fanatic \nYou trapped me once and I thought that \nYou might have it \nSo step down and lend me your ear \n'89 in my time! You, '90 is my year. \n\nYou're weakenin' fast, YO! and I can tell it \nYour body's gettin' hot, so, so I can smell it \nSo don't be mad and don't be sad \n'Cause the lyrics belong to ICE, You can call me Dad \nYou're pitchin' a fit, so step back and endure \nLet the witch doctor, Ice, do the dance to cure \nSo come up close and don't be square \nYou wanna battle me -- Anytime, anywhere \n\nYou thought that I was weak, Boy, you're dead wrong \nSo come on, everybody and sing this song \n\nSay -- Play that funky music Say, go white boy, go white boy go \nplay that funky music Go white boy, go white boy, go \nLay down and boogie and play that funky music till you die. \n\nPlay that funky music Come on, Come on, let me hear \nPlay that funky music white boy you say it, say it \nPlay that funky music A little louder now \nPlay that funky music, white boy Come on, Come on, Come on \nPlay that funky music \n")

#+end_src
** 7
For this one, I pass some time to read on the official spec of aes and did not understood everything.
Then, I realize, as you did mention openssl and as you did not gave as much instructions as before, that you were expecting us to use some already existing library.
Clojure runs on the jvm and I did not find any openssl related stuff so I went with the standard jvm way and made a simple wrapper around the JCE.

I used clojure's native interoperability to call directly some java from clojure.

#+begin_src clojure
;; c7

(m/fact
  (-> "./resources/base64-encoded-aes-encrypted"
      file/ld-simple
      b64/>bytes
      byte/>bytes-array
      (aes/decrypt "YELLOW SUBMARINE")) => "I'm back and I'm ringin' the bell \nA rockin' on the mike while the fly girls yell \nIn ecstasy in the back of me \nWell that's my DJ Deshay cuttin' all them Z's \nHittin' hard and the girlies goin' crazy \nVanilla's on the mike, man I'm not lazy. \n\nI'm lettin' my drug kick in \nIt controls my mouth and I begin \nTo just let it flow, let my concepts go \nMy posse's to the side yellin', Go Vanilla Go! \n\nSmooth 'cause that's the way I will be \nAnd if you don't give a damn, then \nWhy you starin' at me \nSo get off 'cause I control the stage \nThere's no dissin' allowed \nI'm in my own phase \nThe girlies sa y they love me and that is ok \nAnd I can dance better than any kid n' play \n\nStage 2 -- Yea the one ya' wanna listen to \nIt's off my head so let the beat play through \nSo I can funk it up and make it sound good \n1-2-3 Yo -- Knock on some wood \nFor good luck, I like my rhymes atrocious \nSupercalafragilisticexpialidocious \nI'm an effect and that you can bet \nI can take a fly girl and make her wet. \n\nI'm like Samson -- Samson to Delilah \nThere's no denyin', You can try to hang \nBut you'll keep tryin' to get my style \nOver and over, practice makes perfect \nBut not if you're a loafer. \n\nYou'll get nowhere, no place, no time, no girls \nSoon -- Oh my God, homebody, you probably eat \nSpaghetti with a spoon! Come on and say it! \n\nVIP. Vanilla Ice yep, yep, I'm comin' hard like a rhino \nIntoxicating so you stagger like a wino \nSo punks stop trying and girl stop cryin' \nVanilla Ice is sellin' and you people are buyin' \n'Cause why the freaks are jockin' like Crazy Glue \nMovin' and groovin' trying to sing along \nAll through the ghetto groovin' this here song \nNow you're amazed by the VIP posse. \n\nSteppin' so hard like a German Nazi \nStartled by the bases hittin' ground \nThere's no trippin' on mine, I'm just gettin' down \nSparkamatic, I'm hangin' tight like a fanatic \nYou trapped me once and I thought that \nYou might have it \nSo step down and lend me your ear \n'89 in my time! You, '90 is my year. \n\nYou're weakenin' fast, YO! and I can tell it \nYour body's gettin' hot, so, so I can smell it \nSo don't be mad and don't be sad \n'Cause the lyrics belong to ICE, You can call me Dad \nYou're pitchin' a fit, so step back and endure \nLet the witch doctor, Ice, do the dance to cure \nSo come up close and don't be square \nYou wanna battle me -- Anytime, anywhere \n\nYou thought that I was weak, Boy, you're dead wrong \nSo come on, everybody and sing this song \n\nSay -- Play that funky music Say, go white boy, go white boy go \nplay that funky music Go white boy, go white boy, go \nLay down and boogie and play that funky music till you die. \n\nPlay that funky music Come on, Come on, let me hear \nPlay that funky music white boy you say it, say it \nPlay that funky music A little louder now \nPlay that funky music, white boy Come on, Come on, Come on \nPlay that funky music \n")
#+end_src

** 8
For this one, I read between the lines and understood that we were not supposed to crack it, simply to find it based again on pattern.
So I simply sliced each line into blocks of 16 and computed for each their frequency.
As soon as I hit a repetition, I consider the block as ecb encoded and filter it.
I obtain only one result.

#+begin_src clojure
;; c8

(def keysize 16)

(defn aes-encoded?
  "We will count each block and see if there is repetition of the same 16 blocks."
  [b]
  (let [l (- (count b) keysize)]
    (->> (range l)                                                               ;; we will take only the size of the block minus 16 characters
         (reduce
          (fn [m i]
            (update-in m [(->> b (drop i) (take 16))] (fn [o] (if o (inc o) 0)))) ;; we will compute for each 16 blocks of characters, their frequency
          {})
         vals                                                                    ;; list all values
         (apply +)                                                               ;; compute their sum
         pos?)))                                                                 ;; if there is at least 1 repetition, this may very well be the ecb encoded block

(m/fact
  (->> "./resources/hex-encoded-ecb-encrypted"
       file/ld
       (map hex/>bytes)
       (filter aes-encoded?)
       byte/>hex) => "d880619740a8a19b7840a8a31c810a3d08649af70dc06f4fd5d2d69c744cd283e2dd052f6b641dbf9d11b0348542bb5708649af70dc06f4fd5d2d69c744cd2839475c9dfdbc1d46597949d9c7e82bf5a08649af70dc06f4fd5d2d69c744cd28397a93eab8d6aecd566489154789a6b0308649af70dc06f4fd5d2d69c744cd283d403180c98c8f6db1f2a3f9c4040deb0ab51b29933f2c123c58386b06fba186a")
#+end_src

* Conclusion

I loved it.
Thanks.
Am I allowed to continue?

Any feedback to improve myself is appreciated (if you have any time for that at all).

Anyway,

thanks again
It's way fun!

Cheers,
Antoine R. Dumont
