#+title: Beautiful concurrency - notes
#+author: ardumont

- [[https://www.fpcomplete.com/user/simonpj/beautiful-concurrency][Beautiful concurrency]]
- [[http://research.microsoft.com/en-us/um/people/simonpj/Papers/STM/stm.pdf][Composable Memory Transactions]]
- [[http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf][The problems with threads]]
- [[http://www.stanford.edu/~ouster/cgi-bin/papers/threads.pdf][Why threads are a bad idea (for most purposes)]]
- [[http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf][Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign language calls in Haskell]]

* STM
New approach on programming shared memory parallel processors

* Parallelism / Concurrency

** Parallelism

- employs multiple processors to make programs run faster
- performance is the main goal
- ideally idempotency
- semantics of the programs is unchanged compared to a sequential program (ideally)
- has to do with implementation

In haskell:
#+begin_src haskell
Control.Parallel.par :: a -> b -> b
#+end_src

** Concurrency

- describes a situation where non-deterministic behaviour, and many things are going on at once, is part of the specification of the programs.
- must happen even on a uni-processor
- using forkIO to fork an explicit thread is a signal that a program uses concurrency

Ex:
- web server with one-thread per client
- telephone switch

#+begin_src haskell
Control.Concurrent.forkIO :: IO () -> IO GHC.Conc.Sync.ThreadId
#+end_src
* Locks are bad

Too many situations can let hell break loose.

|-------------------------------------+--------------------------------------------------------------------------------------------|
| Cons                                |                                                                                            |
|-------------------------------------+--------------------------------------------------------------------------------------------|
| Take too few locks                  | Multiple threads will modify the variable at the same time -> corrupted data               |
| Take too many locks                 | Inhibit concurrency or deadlock                                                            |
| Take the wrong lock                 | If the program is not clear enough, we cannot determine which lock is used for which data. |
|                                     | Increase the probability to take the wrong lock -> corrupted data                          |
| Error Recovery                      | Hard. How to ensure there is no inconsistency when problem arise                           |
| Lost wake-ups and erroneous retries |                                                                                            |
| Break modularity                    | Basic means of combining from smaller programs is no longer possible                       |
|                                     |                                                                                            |
|-------------------------------------+--------------------------------------------------------------------------------------------|
