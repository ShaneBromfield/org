#+BLOG: tony-blog
#+POSTID: 675
#+DATE: [2012-12-25 Tue 16:09]
#+TITLE: Daily git
#+AUTHOR: Antoine R. Dumont
#+OPTIONS:
#+TAGS: emacs, git, aliases
#+CATEGORY: emacs, git
#+DESCRIPTION: How do i use git every day
#+STARTUP: indent
#+STARTUP: hidestars

In another post, I presented my (system) git aliases.
In this one, I will enter into more details about those commands.

I have mainly 2 ways of using git:
- [[http://en.wikipedia.org/wiki/Command-line_interface][CLI]]
- [[http://philjackson.github.com/magit/magit.html][magit]] through [[http://www.gnu.org/s/emacs/][emacs]]

I prefer [[http://philjackson.github.com/magit/magit.html][magit]] (from inside [[http://www.gnu.org/software/emacs/][emacs]]) but I still use the [[http://en.wikipedia.org/wiki/Command-line_interface][CLI]] from time to time.
Here I will present my [[http://en.wikipedia.org/wiki/Command-line_interface][CLI]] use.
I'll keep [[http://philjackson.github.com/magit/magit.html][magit]] for another time.

* =gbr=
=git branch=

To see the list of branches you have on your current repository.

#+BEGIN_SRC sh
tony@dagobah(0.46,) 15:48:41 ~/repo/perso/dot-files (master) $ gbr
 * master
#+END_SRC
_Explanation:_
Here, I only have locally the master branch.

=gbr -r= or =gbr --remote= to see the remote branches:
#+BEGIN_SRC sh
tony@dagobah(0.36,) 16:41:11 ~/repo/perso/dot-files (master) $ gbr --remote
  origin/HEAD -> origin/master
  origin/master
  origin/test
#+END_SRC
_Explanation:_
Remotely I see other branches, here *master* and *test*.

* =gco=
Just to move oneself from the current branch to another or creating a new one:
** Create
#+BEGIN_SRC sh
gco -b new-branch
#+END_SRC

Example:
#+BEGIN_SRC sh
tony@dagobah(0.33,) 21:31:56 ~/repo/perso/dot-files (master) $ gco -b new-branch
Switched to a new branch 'new-branch
tony@dagobah(0.38,) 21:32:03 ~/repo/perso/dot-files (new-branch) $
#+END_SRC
** Move
#+BEGIN_SRC sh
gco master
#+END_SRC

Example:
#+BEGIN_SRC sh
tony@dagobah(0.38,) 21:32:03 ~/repo/perso/dot-files (new-branch) $ gco master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
tony@dagobah(0.35,) 21:32:05 ~/repo/perso/dot-files (master) $
#+END_SRC

** Discard changed
To discard changes in current directory

Example:
#+BEGIN_SRC sh
tony@dagobah(0.13,) 21:33:57 ~/repo/perso/dot-files (master) $ echo 'toto' >> README.org

tony@dagobah(0.11,) 21:34:05 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 6 commits.
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   README.org
#
no changes added to commit (use "git add" and/or "git commit -a")

tony@dagobah(0.11,) 21:34:06 ~/repo/perso/dot-files (master) $ gco -- README.org

tony@dagobah(0.09,) 21:34:17 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 6 commits.
#
nothing to commit (working directory clean)

#+END_SRC
_Explanation:_
- First we create some changes (=echo=)
- Then we check the status, there is one file that has changed (indeed the *README.org*)
- We removed those changes for the file (=gco -- README.org=)
- When we recheck the status, nothing has changed!

* =gdf=
=git diff=

To see the modifications you developed between your workspace and the commited files.

Example:
#+BEGIN_SRC sh
tony@dagobah(0.31,) 18:05:22 ~/repo/perso/dot-files (master) $ gdf
diff --git a/README.md b/README.md
index 0358d27..35e6c13 100644
--- a/README.md
+++ b/README.md
@@ -12,3 +12,4 @@ Something along those lines should do the trick:
 REPO=/path/to/your/clones/dot-files
 for i in $(ls $REPO); do ln -s $REPO/$i ~; done
 ```
+this is a test
#+END_SRC

_Explanation:_
Here we can see that the file /README.md/ has one more line *this is a test*.

*Note*
If you already staged your modifications you can use =gdf --cached=.

Example:
#+BEGIN_SRC sh
tony@dagobah(0.28,) 18:06:36 ~/repo/perso/dot-files (master) $ git add README.md
tony@dagobah(0.28,) 18:06:38 ~/repo/perso/dot-files (master) $ gdf
tony@dagobah(0.26,) 18:06:39 ~/repo/perso/dot-files (master) $ gdf --cached
diff --git a/README.md b/README.md
index 0358d27..35e6c13 100644
--- a/README.md
+++ b/README.md
@@ -12,3 +12,4 @@ Something along those lines should do the trick:
 REPO=/path/to/your/clones/dot-files
 for i in $(ls $REPO); do ln -s $REPO/$i ~; done
 ```
+this is a test

#+END_SRC
_Explanation:_
- =git add README.md= staged your modification
- =gdf= did not show any difference because you already staged all modifications
- =gdf --cached= activated the comparison including the index.

* =gst=
=git status=

This will list the current status of your index (modification, untracked files):

Example:
#+BEGIN_SRC sh
tony@dagobah(0.20,) 17:07:59 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   README.md
#
no changes added to commit (use "git add" and/or "git commit -a")
#+END_SRC

_Explanation:_
You can see that:
- the file /README.md/ has been changed.
- this has not been staged for commit, that is, I did not added it to the index yet.

* =git add=
Add modifications into the git index.

If I add the /README.md/ file to the index and then check the status:
#+BEGIN_SRC sh
tony@dagobah(0.20,) 17:08:00 ~/repo/perso/dot-files (master) $ git add README.md
tony@dagobah(0.19,) 17:08:03 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.md
#
#+END_SRC
_Explanation:_
The index status changed from *Changes not staged for commit* to *Changes to be committed*.
This time I added the /README.md/ to the index. So, now we are ready to commit.

* =gci=
=git commit -v=

Commit the content of the index.

By typing =gci= in the CLI, the git *core.editor* loads itself and asks you for a commit message:
#+BEGIN_SRC sh
------> Here you type the commit message <------
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.md
#
diff --git a/README.md b/README.md
index 0358d27..35e6c13 100644
--- a/README.md
+++ b/README.md
@@ -12,3 +12,4 @@ Something along those lines should do the trick:
 REPO=/path/to/your/clones/dot-files
 for i in $(ls $REPO); do ln -s $REPO/$i ~; done
 ```
+this is a test
#+END_SRC
*Note*:
At the same time, we see the modifications between the index and the already gitted file.

_Explanation:_
I you type a commit message, for example *Temporary commit* then save the modifications and close the editor.
The content of the index is *commited* (message included).

#+BEGIN_SRC sh
tony@dagobah(0.19,) 17:08:04 ~/repo/perso/dot-files (master) $ gci
[master 05dfb35] Temporary commit
 1 file changed, 1 insertion(+)
tony@dagobah(0.30,) 17:08:16 ~/repo/perso/dot-files (master) $ gst
#+END_SRC

* =gci --amend=

Reedit the content of the last commit, either:
- the commit message
- or the files that are contained in the commit.

=gci --amend= will reopen the editor but this time with your last commit message already typed:
#+BEGIN_SRC sh
Temporary commit.

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is ahead of 'origin/master' by 1 commit.
#
# Changes to be committed:
#   (use "git reset HEAD^1 <file>..." to unstage)
#
#       modified:   README.md
#
diff --git a/README.md b/README.md
index 0358d27..35e6c13 100644
--- a/README.md
+++ b/README.md
@@ -12,3 +12,4 @@ Something along those lines should do the trick:
 REPO=/path/to/your/clones/dot-files
 for i in $(ls $REPO); do ln -s $REPO/$i ~; done
 ```
+this is a test
#+END_SRC

Then edit for example this commit message to *This is a temporary commit to demonstrate the power of git*.
Then save and close the editor.

#+BEGIN_SRC sh
tony@dagobah(0.19,) 17:19:45 ~/repo/perso/dot-files (master) $ gci --amend
[master 2c40a11] This is a temporary commit to demonstrate the power of git.
 1 file changed, 1 insertion(+)
#+END_SRC

[[http://git-scm.com/book/ch2-4.html#Changing-Your-Last-Commit][for more information]]
* =git rm=
Remove files or folder and add those modifications into the git index.
This is the dual to =git add=.

Example:
#+BEGIN_SRC sh
tony@dagobah(0.55,) 21:47:28 ~/repo/perso/dot-files (master) $ git rm some-test-file
rm 'some-test-file'
tony@dagobah(0.51,) 21:47:34 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 6 commits.
#
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       deleted:    some-test-file
#
tony@dagobah(0.51,) 21:47:35 ~/repo/perso/dot-files (master) $ gci
[master d74715b] Delete useless file.
 0 files changed
 delete mode 100644 some-test-file
tony@dagobah(0.90,) 21:47:42 ~/repo/perso/dot-files (master) $
#+END_SRC
_Explanation:_
- Remove the *some-test-file* (=git rm=)
- Check the status, we see that the destruction of the file is to be commited. (=gst=)
- Commit 'Delete useless file' (=gci=)

* =git ls-files -d | xargs git rm=
When you deleted lots of files and forgot to use =git rm=.
You can rapidly improve your situation with this command.

#+BEGIN_SRC sh
tony@dagobah(0.20,) 18:11:09 ~/repo/perso/dot-files (master) $ rm titi tutu tata
tony@dagobah(0.16,) 18:11:27 (1) ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 2 commits.
#
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       deleted:    tata
#       deleted:    titi
#       deleted:    tutu
#
no changes added to commit (use "git add" and/or "git commit -a")
tony@dagobah(0.13,) 18:11:35 ~/repo/perso/dot-files (master) $ git ls-files -d | xargs git rm
rm 'tata'
rm 'titi'
rm 'tutu'

#+END_SRC

_Explanation:_
- First we delete the file we do not want anymore (the must would have been to use directly =git rm=)
- Then checking the status of the repository, we see that we must =git rm= the files.
- At last, we fix the situation by listing all the files to 'git rm'

*Note* An alias could be cool here :D

* =git mv=
Move one file from one destination to another.
It's the same as the *mv* command, but has the advantage to add the move action to the git index too.

#+BEGIN_SRC sh
tony@dagobah(0.22,) 18:14:29 ~/repo/perso/dot-files (master) $ git mv test some-test-file
tony@dagobah(0.27,) 18:14:38 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 3 commits.
#
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       renamed:    test -> some-test-file
#

#+END_SRC
_Explanation:_
We rename the *test* file into *some-test-file*.
This modification is immediately staged into the index.

* =git reset=
** soft
=git reset --soft=

To unstage commited modifications from the index.
This also let the workspace intact, that is with your modifications.

(*--soft* is optional)
#+BEGIN_SRC sh
git reset HEAD~
#+END_SRC
_Explanation:_
This will:
- remove the last commit (between =HEAD= and =HEAD~=)
- keep the modifications you last commited

*Note*
You can do this with a greater interval =HEAD~10= for 10 commits before HEAD.

Example:
#+BEGIN_SRC sh
tony@dagobah(0.11,) 18:17:19 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 5 commits.
#
nothing to commit (working directory clean)

tony@dagobah(0.29,) 19:46:58 ~/repo/perso/dot-files (master) $ git last
commit fccd142e7388304075c6878e3bc85bfee8b8583b
Author: Antoine R. Dumont <antoine.romain.dumont@gmail.com>
Date:   Tue Dec 25 18:17:14 2012 +0100

    A new file README.org for fun.

tony@dagobah(0.33,) 19:47:05 ~/repo/perso/dot-files (master) $ git reset HEAD~

tony@dagobah(0.25,) 19:47:45 ~/repo/perso/dot-files (master) $ gst
# On branch master
# Your branch is ahead of 'origin/master' by 4 commits.
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       README.org
nothing added to commit but untracked files present (use "git add" to track)

#+END_SRC
_Explanation:_
- Check the current status of the repository, we got 5 commits.
- Last commit has for message *A new file for fun.*
- Reset softly the last commit.
- Then when we check again, we got 4 commits now and we see only one file *README.org* which is untracked.
- So we did not lose the last commit's modification, only the message. This is a soft reset.

** hard
=git reset --hard=

To unstage commited modifications from the index.
This also revert the workspace back to the indicated [[http://git-scm.com/book/en/Git-Internals-Git-Objects][git's SHA1]].

#+BEGIN_SRC sh
git reset --hard HEAD~
#+END_SRC
_Explanation:_
This will:
- remove the last commit (between =HEAD= and =HEAD~=)
- lost any last commited modifications

Litteraly, you get back one commit back in time (=HEAD~=)

*Note*
You're not limited to one commit back (e.g. =HEAD~3=)

* =git blame=
Just use to see by whom the modifications have been done.
Thus engaging in a discussion to help understand the code they did.

In my *dot-files* repository, if I =git blame .stumpwmrc=, I have the following starting output:

#+BEGIN_SRC sh
894dc3ac (Denis                   2011-06-19 23:43:16 +0200   1) ;; Hey, Emacs! This is a -*- lisp -*- file!
894dc3ac (Denis                   2011-06-19 23:43:16 +0200   2)
1d5aaa86 (Denis Labaye            2011-07-01 10:59:05 +0200   3) (setf *frame-number-map* "abcdefghijklmnopqrst")
894dc3ac (Denis                   2011-06-19 23:43:16 +0200   4)
1d5aaa86 (Denis Labaye            2011-07-01 10:59:05 +0200   5) (setf *window-format* "%m%n%s nm=%50t cl=%c id=%i")
894dc3ac (Denis                   2011-06-19 23:43:16 +0200   6)
e084e02b (Antoine Romain Dumont   2011-07-31 20:17:51 +0200   7) ;;(run-commands "restore-from-file ~/.stumpwm.screendump")
894dc3ac (Denis                   2011-06-19 23:43:16 +0200   8)
3be82213 (Antoine R. Dumont       2012-08-12 14:44:30 +0200   9) (defcommand terminal () ()
2b4ea20d (Antoine Romain Dumont   2011-07-31 18:10:24 +0200  10)   "run an xterm instance or switch to it, if it is already running."
3be82213 (Antoine R. Dumont       2012-08-12 14:44:30 +0200  11)   (run-or-raise "gnome-terminal --title=xterm1 --hide-menubar" '(:class "Gnome-terminal")))
3be82213 (Antoine R. Dumont       2012-08-12 14:44:30 +0200  12) (define-key *root-map* (kbd "x") "terminal")
e9912dae (Antoine Romain Dumont   2011-07-16 17:36:10 +0200  13)
e5a5ce33 (Antoine R. Dumont       2012-12-18 04:18:50 +0100  14) (defcommand ssh-add-identities () ()
e5a5ce33 (Antoine R. Dumont       2012-12-18 04:18:50 +0100  15)   "Add the identities present in ~/.ssh-agent-identities script."
58299192 (Antoine R. Dumont       2012-08-12 19:22:08 +0200  16)   (run-shell-command "~/bin/ssh/ssh-add.sh"))

#+END_SRC
_Explanation:_
For each line (I limited to the first 16th lines), we see which developer modified lastly what.

As an example, I can ask Denis what the =(setf *frame-number-map* "abcdefghijklmnopqrst")= is all about :D

*Note*

By the way, it was an example :D.

This command told [[http://www.nongnu.org/stumpwm/][stumpwm]] to use the alphabet as the numerotation for the frame.

* =git rebase=

Once upon a time, I did a lot of [[http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merging][merge]]. Then I discovered [[http://git-scm.com/book/en/Git-Branching-Rebasing][rebase]].
[[http://git-scm.com/book/en/Git-Branching-Rebasing][Rebase]] permits to let you play back your commits from another moment in time.

Let's put it this way:
- You begin your development at the moment *A*
- you create a branch from this *A*, thus follows commits *B*, ..., *E*
- You finish at moment *E*.
- Bob also starts from *A* and finish to *H* before you
- Bob integrates this *H* into the main branch
- You replay your commits from this *H* moment, so you got new commit *b* to *e* commits (it's still your commits but the SHA1 changed because the parent commit changed too!)
In the end, it's like as if you began your commits from this *H* moment.

This way:
- you keep the git history inlined which is simpler to follow
- when replaying the commits, if you got any conflict, you can take them down one at a time

*Note*
One danger with the rebase is if you already pushed your development and someone left from your development, there will be divergence.
[[http://git-scm.com/book/en/Git-Branching-Rebasing#The-Perils-of-Rebasing][For more information]]

Example:
- I made some dev on the branch *some-dev* (5 commits after master)
- I made some other dev from the same original commit but on another branch *some-other-dev*
[[./resources/git/rebase/status.png]]
- Now we can see that the 2 branches *some-dev* and *some-other-dev* have a common ancestor
- master is advanced according to *some-other-dev*
#+BEGIN_SRC sh
gco master
git merge some-other-dev
#+END_SRC

*Note*
Here I use the merge to only fast-forward the branch master according to *some-other-dev*

[[./resources/git/rebase/master-synced-with-some-other-dev.png]]

- Now master and *some-dev* have diverged
- I place myself to the branch *some-dev* and rebase my work from the master branch.
#+BEGIN_SRC sh
git co some-dev
git rebase master
#+END_SRC

I first got a conflict because both the first commit of the branch does the same modifications
[[./resources/git/rebase/conflict.png]]

- I edit the conflicted file, chose the first implementation, and save the file
- I add the modification to the index (=git add README.md=) and relaunch the rebase (=git rebase --continue=)

#+BEGIN_SRC sh
git add README.md
git rebase --continue
#+END_SRC

- Once the rebase is done, all is good, we obtain an inlined history
[[./resources/git/rebase/rebased-final.png]]

- We can fast-forward the *master* with *some-dev*
[[./resources/git/rebase/master-ff.png]]

#+BEGIN_SRC sh
git co master
git rebase some-dev
#+END_SRC

* =git rebase -i=
Also named interactive rebase.

This is another awesome git functionality.
This command permits you to rewrite your commits.

Once you are done developing the functionality you were aiming to do.
You can:
- [[http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html][squash your commits together]]
- remove some (if rendered useless)
- reedit the commit messages (to more appropriate ones), etc...

At the end of it, your history is rewritten and is more straight-forward for others to see.

*Note*
Beware, that with rewriting history has limits.
Typically, do not rewrite your history if the branch is remote and used by others.

[[http://git-scm.com/book/en/Git-Tools-Rewriting-History#Changing-Multiple-Commit-Messages][For more information]]

#+./resources/git/rebase/status.png http://adumont.fr/blog/wp-content/uploads/2012/12/wpid-status.png
#+./resources/git/rebase/master-synced-with-some-other-dev.png http://adumont.fr/blog/wp-content/uploads/2012/12/wpid-master-synced-with-some-other-dev.png
#+./resources/git/rebase/conflict.png http://adumont.fr/blog/wp-content/uploads/2012/12/wpid-conflict.png
#+./resources/git/rebase/rebased-final.png http://adumont.fr/blog/wp-content/uploads/2012/12/wpid-rebased-final.png
#+./resources/git/rebase/master-ff.png http://adumont.fr/blog/wp-content/uploads/2012/12/wpid-master-ff.png
