#+title: Reactive programming

* DONE week 1 [100%]
CLOSED: [2013-11-12 mar. 12:52]
** DONE What is reactive programming?
CLOSED: [2013-11-05 mar. 14:15]

Reactive: readily responsive to stimulus

Reacts to:
- events (event-driven)
- load (scalable)
- failures (resilient)
- users (responsive)


Event-driven -> scalable  ->
             -> resilient -> responsive
                          ->


*** Traditionally
multiple threads (shared, synchronized state) -> strong coupling, hard to compose

*** Now
composed from loosely coupled event-handlers -> events can be handled asynchronously, without blocking

*** scalable
an applications is scalable if it can expand according to its usage:
- scale up: make use of parallelism in multi-core system
- scale out: make use of multiple server nodes

important for scalability: minimize shared mutable state
important for scale out: location transparency, resilience


*** resilient
recover quickly from failure

failures can be:
- software
- hardware
- connection

it is not an afterthought, it needs to be part of the design from the beginning

*** responsive

rich, real-time interaction with its users even under load and in the presence of failures

*** fundamental constructions
to get composable event abstractions
- events are first-class
- events are often represented as messages
- handlers of events are also first-class
- complex handlers can be composed from primitive ones

** DONE Recap: Functions and Pattern Matching
CLOSED: [2013-11-05 mar. 14:16]
** DONE Recap: Collections
CLOSED: [2013-11-05 mar. 14:23]
** DONE Functional random generators
CLOSED: [2013-11-06 mer. 13:04]
** DONE Monads
CLOSED: [2013-11-10 dim. 19:19]

*** Def
monad M is a parametric type M[T] with 2 operations, flatMap (bind) and unit that have to satisfy some laws:
- associativity
- left unit
- right unit

In scala, we can see the monad as a trait:

#+begin_src scala
trait M[T] {
  def flatMap[U](f: T => M[U]): M[U]
}

def unit[T](x: T): M[T]
#+end_src

Example of monads:
- List with unit(x) is List(x)
- Set with unit(x) is Set(x)
- Option with unit(x) is Some(x)
- Generator with unit(x) is single(x)
*** Monads and map

map can be defined as a combination between flatMap and unit.

#+begin_src scala
m map f == m flatMap (f andThen unit)
#+end_src

*** Monad laws
*** Associativity

(m flatMap f) flatMap g == m flatMap ( x => f(x) flatMap g f)

*** Left unit

unit(x) flatMap f == f(x)

*** Right unit
m flatMap unit == m
* IN-PROGRESS week 2 [100%]
** DONE 4 - 1 - Functions and State
CLOSED: [2013-11-12 mar. 13:16]
Without side effect, the concept of time is not important.

Substitution model: programs can be evaluated by rewriting.
As there is no side effect, only reformulation of one's program by replacing each call by it's definition expanding the values.

*** Remarks

Rewriting can be done anywhere in a term.

All rewritings which terminate lead to the same result -> confluence (a.k.a Church-Rosser theorem)

*** Stateful objects
Stateful -> changes over the course of time.

"an object has a state if its behavior is influenced by its history"

*** Implementation of state

In scala, every form of mutable state is constructed from variables.

*** State in objects

objects with state -> objects with variable

Example: Bank Account

#+begin_src scala
 class BankAccount {
  private var balance = 0
  def deposit(amount: Int): Unit = {
    if (amount > 0) balance += amount
  }

  def withdraw(amount: Int): Int = {
    if (0 < amount && amount <= balance) {
      balance -= amount
        balance
    }
  }
}

val acct = new BankAccount
acct deposit 50
acct withdraw 20
acct withdraw 20
acct withdraw 15 // -> Error

#+end_src

*** Statefulness and variables

**** Example 1
#+begin_src scala
def cons[T](hd: T, tl: => Stream[T]) = new Stream[T] {
    def head = hd
    private var tlOpt: Option[Stream[T]] = None
    def tail: T = tlOpt match {
      case Some(x) => x
      case None    => tlOpt = Some(tl); tail
    }
}
#+end_src

Is the result of cons a stateful object?

- No   -> if the tail is pure (without side effect), this is not.

- Yes  -> if the tail is side-effecty, tail will depend on the history so yes

**** Example2

#+begin_src scala
class BankAccountProxy(ba: BankAccount) {
  def deposit(amount: Int): Unit = ba.deposit(amount)
  def withdraw(amount: Int): Int = ba.withdraw(amount)
}
#+end_src

Are instances of BankAccountProxy stateful objects?

Yes -> same call won't result in the same result each time.

** DONE 4 - 3 - Identity and Change
CLOSED: [2013-11-12 mar. 13:31]
*** Assignment poses new problem
Assignment poses the new problem of deciding whether 2 expressions are the same.

#+begin_src scala
val x = E; val y = E; // -> safe to assume that x and y are the same (val so no assignment).
#+end_src

we could also have written:

#+begin_src scala
val x = E; val y = x;
#+end_src

-> referential transparency

*** Example

#+begin_src scala
val x = new BankAccount
val y = new BankAccount
#+end_src

Are x and y are the same?
No

*** What's "being the same"?

property of "operational equivalence" <-> x and y are operationally equivalent if no possible test can distinguish between them.

How:
- Execute multiple arbitrary definitions on both x and y and check the possible outcomes.
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
f (x, y)
#+end_src

- Then execute the definitions with another sequence S obtained by replacing each x occurrence by y
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
f (x, x)
#+end_src

- Then create another sequence S' by replace x by y in every sequence of S
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
f (y, y)
#+end_src

- if the results are different then the expressions x and y are certainly different

- if all possible pairs of sequences (S, S') produce the same result, then x and y are the same.

*** Example

**** First round

#+begin_src scala
val x = new BankAccount
val y = new BankAccount
x deposit 30  // val res1: Int = 30
y withdraw 20 // -> error
#+end_src

**** Second
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
x deposit 30  // val res1: Int = 30
x withdraw 20 // val res1: Int = 10
#+end_src

**** conclusion

The final result is different then x and y are different

*** Another Example

#+begin_src scala
val x = new BankAccount
val y = x
x deposit 30  // val res1: Int = 30
y withdraw 20 // -> error
#+end_src

Here, using the same experiment, we obtain the same result so x and y are the same.

*** Assignment and substitution model
With previous examples, we can see that the substitution model can no longer be used with assignments.

** DONE 4 - 4 - Loops
CLOSED: [2013-11-12 mar. 14:13]
With assignment, variables are enough to model all imperative programs.
Loop is an unnecessary construct.

Example of the "power" method using the useless native while operation.

*** WHILE

WHILE as a functional function:

#+begin_src scala
def WHILE(condition: => Boolean)(command: => Unit): Unit =
 if (condition) {
   command
   WHILE(condition)(command)
} else ()
#+end_src

Note:
- condition and command must be passed by name so that they're reevaluated in each iteration
- WHILE is tail-recursive so it can operate with a constant stack size

*** REPEAT

Write a function implementing a repeat loop (Repeat the command until the condition is met).

#+begin_src scala
def REPEAT(command: => Unit)(condition: => Boolean): Unit = {
  command
  if (condition) ()
  else REPEAT(command)(condition)
}
#+end_src

** DONE 4 - 5 - Extended Example - Discrete Event Simulation
CLOSED: [2013-11-12 mar. 22:54]
*** Digital circuit
It's composed of:
- wires (transport signals)
- functional components (transform signals)

based components:
- inverter - output is the inverse of its input
- AND      - output is the conjunction of the inputs
- OR       - output is the disjunction of the inputs

Other components are built by combining these base components.

/Note/
Components have a reaction time (delay). Their outputs do not change immediately after a change of their inputs.

*** Diagram - basic

[[./resources/basic-components.png]]

FIXME crop

*** Diagram - combine

[[./resources/combine-basic-in-half-adder.png]]

FIXME crop

*** Gates

#+begin_src scala
def inverter(input: Wire, output: Wire): Unit
def andGate(a1: Wire, a2: Wire, output: Wire): Unit
def orGate(o1: Wire, o2: Wire, output: Wire): Unit
#+end_src

*** Constructing Components

**** Half-adder

Definition:
s = a | b & !(a & b)
c = a & b

#+begin_src scala
def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire): Unit = {
  val d = new Wire
  val e = new Wire

  orGate(a, b, d)
  andGate(a, b, c)
  inverter(c, e)
  andGate(d, e, s)
}
#+end_src

[[./resources/half-adder.png]]

**** Full-adder

composed of 2 full-adders:

#+begin_src scala
def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {
  val s = new Wire
  val c1 = new Wire
  val c2 = new Wire

  halfAdder(b, cin, s, c1)
  halfAdder(a, s, sum, c2)
  orGate(c1, c2, cout)
}
#+end_src

[[./resources/full-adder.png]]


**** Exercise: Mystery function

#+begin_src scala
def f(a: Wire, b: Wire, c: Wire): Unit = {
  val d, e, f, g = Wire
  inverter(a, d)
  inverter(b, e)
  andGate(a, e, f)
  andGate(b, d, g)
  orGate(f, g, c)
}
#+end_src

Question: What logical function does this program describe?

Answer: a != b (xor)

d = !a
e = !b
f = a & !b
g = b & !a
c = f | g = (a & !b) | (b & !a)

|---+---+---+--------+--------+---|
|   | a | b | a & !b | b & !a | c |
|---+---+---+--------+--------+---|
|   | 0 | 0 |      0 |      0 | 0 |
|   | 1 | 0 |      1 |      0 | 1 |
|   | 0 | 1 |      0 |      1 | 1 |
|   | 1 | 1 |      0 |      0 | 0 |
|---+---+---+--------+--------+---|

xor

** DONE 4 - 6 - Discrete Event Simulation_ API and Usage
CLOSED: [2013-11-12 mar. 23:37]
*** Discrete event Simulation
a discrete event simulator performs actions, specified by the user at a given moment.

A action is a function that does not take any parameters and which returns Unit:

#+begin_src scala
type Action = () => Unit
#+end_src

The time is simulated, it has nothing to do with actual time.

*** Simulation trait

A concrete simulation happens inside an object that inherits from the trait Simulation:

#+begin_src scala
trait Simulation {
  // return the current simulated time
  def currentTime: Int = ???
  // registers an action to perform after a certain delay (relative to currentTime)
  def afterDelay(delay: Int)(block: => Unit): Unit = ???
  // performs the simulation until there are no more actions waiting
  def run(): Unit = ???
}
#+end_src

*** Class diagram

Simulation
    |
Gates           Wire, AND, OR, INV
    |
Circuits        HA, ADDER
    |
MySimulation

*** The Wire Class
3 basic operations:

#+begin_src scala
class Wire extends Simulation {
  getSignal: Boolean
  setSignal(sig: Boolean): Unit

  // Attaches the specified procedure to the actions of the wire. All of the attached actions are executed at each change of the transported signal.
  addAction(a: Action): Unit
}
#+end_src


*** Wire implem.

#+begin_src scala
class Wire extends Simulation {
  private var sigVal = false
  private var actions: List[Action] = List()

  getSignal: Boolean = sigVal

  setSignal(sig: Boolean): Unit =
    if (s != sigVal) {
      sigVal = s
      actions foreach(_())                        // use foreach because of the signature returning Unit
    }

  addAction(a: Action): Unit = {
    actions = a :: actions
    a()
  }
}

#+end_src

*** Inverter

installing an action on its input wire.

#+begin_src scala
def inverter(input: Wire, output: Wire) = {
  def invertAction(): Unit = {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) { output setSignal !inputSig }
  }

  input addAction invertAction
}
#+end_src

*** And Gate

#+begin_src scala
def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
  def andAction(): Unit = {
    val in1Sig = in1.getSignal
    val in2Sig = in2.getSignal
    afterDelay(AndGateDelay) { output setSignal (in1Sig & in2Sig) }
  }

  in1 addAction andAction
  in2 addAction andAction
}
#+end_src

*** Or Gate
#+begin_src scala
#+begin_src scala
def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
  def orAction(): Unit = {
    val in1Sig = in1.getSignal
    val in2Sig = in2.getSignal
    afterDelay(OrGateDelay) { output setSignal (in1Sig | in2Sig) }
  }

  in1 addAction orAction
  in2 addAction orAction
}

#+end_src

** DONE 4 - 7 - Discrete Event Simluation_ Implementation and Test
CLOSED: [2013-11-13 mer. 00:04]
*** Simulation trait

#+begin_src scala
trait Simulation {
  type Action = () => Unit
  case class Event(time: Int, action: Action)
  private type Agenda = List[Event]
  private var agenda: Agenda = List()
}
#+end_src

*** Handling time

*** AfterDelay implem.

#+begin_src scala
def afterDelay(delay: Int)(block: => Unit): Unit = {
  val item = Event(currentTime + delay, () => block)
  agenda = insert(agenda, item)
}

private def insert(ag: List[Event], item: Event): List[Event] = ag match {
  case first :: rest if first.time <= item.time =>
    first :: insert(rest, item)
  case _ => item :: ag
}
#+end_src


*** The Event handling Loop

#+begin_src scala
private def loop(): Unit = agenda match {
  case first :: rest =>
    agenda = rest
    curtime = first.time
    first.action()
    loop()
  case Nil =>
}
#+end_src

*** The run method

#+begin_src scala
def run(): Unit = {
  afterDelay(0) {
    println("*** simulation started, time = " + currentTime + " ***")
  }
  loop()
}
#+end_src

*** Probes

A way to examine the changes of the signals on the wires:

#+begin_src scala
def probe(name: String, Wire: Wire): Unit = {
  def probeAction(): Unit = {
    println(s"$name $currentTime value = ${wire.getSignal}")
  }
  wire addAction probeAction
}
#+end_src

*** Defining Technology-Dependent Parameters

#+begin_src scala
trait Parameters {
  def InverterDelay = 2
  def AndGateDelay = 3
  def OrGateDelay = 5
}
#+end_src

We can add another trait to the MySimulation:
#+begin_src scala
object MySimulation extends Circuits with Parameters
#+end_src

*** Circuits

#+begin_src scala
class Circuits extends {
  def half-adder...
  def full-adder...
}
#+end_src
* IN-PROGRESS week 3 [20%]
** DONE 5 - 1 - Monads and Effects
CLOSED: [2013-11-19 mar. 09:53]
|--------------+-----------+---------------|
|              | One       | Many          |
|--------------+-----------+---------------|
| Synchronous  | Try[T]    | Iterable[T]   |
| Asynchronous | Future[T] | Observable[T] |
|--------------+-----------+---------------|

*** Simple adventure game

#+begin_src scala
trait Adventure {
  def collectCoins(): List[Coin]
  def buyTreasure(coins: List[Coin]): Treasure
}
#+end_src

No as simple as we may think since me need to deal with failure.
This does not appear when orchestrating code

*** Actions may fail

We need to add the failure.

If we look at implementation details in collectCoins and buyTreasure, we see the unhappy path.

*** Sequential composition of actions that may fail

*** Expose possibility of failure in the types, honestly

From: T => S
To: T => Try[S]

*** Making failure evident in the type

Using:
#+begin_src scala
import scala.util.{Try, Success, Failure}

abstract class Try[T]
case class Success[T](elem: T) extends Try[T]
case class Failure[T](t: Throwable) extends Try[Nothing]
#+end_src

Now the trait becomes:

#+begin_src scala
trait Adventure {
  def collectCoins(): Try[List[Coin]]
  def buyTreasure(coins: List[Coin]): Try[Treasure]
}
#+end_src

*** Dealing with failure explicitely

Code becomes uglier but it reflects the reality we ever meant:
#+begin_src scala
val adventure = Adventure()

val coins: Try[List[Coin]] = adventure.collectCoins()

val treasure: Try[Treasure] = coins match {
  case Success(cs)        => adventure.buyTreasure(cs)
  case failure@Failure(t) => failure
}
#+end_src

*** HOF to manipulate Try[T]

#+begin_src scala
def flatMap[S](f: T => Try[S]): Try[S]
def flatten[U <: Try[T]]: Try[U]
def map[S](f: T => S): Try[T]
def filter(p: T => Boolean): Try[T]
def recoverWith(f: PartialFunction[Throwable, Try[T]]): Try[T]
#+end_src

*** Monads guide you through the happy path

Try[T], a monad (has flatMap + previous rules) that handles exceptions

Effects are visible in the type.


*** Noise reduction

1. Using flatMap
#+begin_src scala
val adventure = Adventure()

val treasure: Try[Treasure] =
  adventure.collectCoins().flatMap(coins => adventure.buyTreasure(coins))
#+end_src

2. Using for-comprehension (flatMap inside :D)
#+begin_src scala
val adventure = Adventure()

val treasure: Try[Treasure] =
  for(coins <- adventure.collectCoins;
      treasure <- adventure.buyTreasure(coins)) yield treasure
#+end_src

*** HOF to manipulate Try[T]

Object companion of Try (called at construction if memory serves me well):

#+begin_src scala
object Try {
  def apply[T](r: => T): Try[T] = { // r call by name to delay the execution
    try { Success(r) }
    catch { case t => Failure(t) }
  }
}
#+end_src

Map implementation of Try:

#+begin_src scala
def map[S](f: T => S): Try[S] = this match {
  case Success(value)     => Try(f(value))
  case failure@Failure(t) => failure
}
#+end_src

Try helps in materializing the exceptions!

*** Quiz
FlatMap implementation:

#+begin_src scala
def flatMap[S](f: T => Try[S]): Try[S] = this match {
  case Success(value)     => try { f(value) } catch { case t => Failure(t) }
  case failure@Failure(t) => failure
}
#+end_src


** IN-PROGRESS 5 - 3 - Latency as an Effect

*** A simple adventure game... is very similar to a simple network stack
#+begin_src scala
trait Socket {
  def readFromMemory(): Array[Byte]
  def sendToEurope(packet: Array[Byte]): Array[Byte]
}

val socket = new Socket()
val packet = socket.readFromMemory()
val confirmation = socket.sendToEurope(packet)
#+end_src

Side-effects apparent?

*** Timings for various operations on a typical PC on human scale
Peter Norvig's table

|-------------------------------------+------------------|
| Instructions                        | Time             |
|-------------------------------------+------------------|
| execute typical instruction         | 1 s              |
| fetch from L1 cache memory          | 0.5 ns           |
| branch misprediction                | 5 ns             |
| fetch from L2 cache memory          | 7 ns             |
| mutex lock/unlock                   | 25 ns            |
| fetch from main memory              | 100 ns           |
| send 2k bytes over 1Gbps network    | 20, 000 ns       |
| read 1Mb sequentially from memory   | 250, 000 ns      |
| fetch from new disk location (seek) | 8, 000, 000 ns   |
| read 1Mb sequentially from disk     | 20, 000, 000 ns  |
| send packet US to Europe and back   | 150, 000, 000 ns |
|-------------------------------------+------------------|

*** Sequential composition of actions that take time
#+begin_src scala
val socket = new Socket()
val packet = socket.readFromMemory()
// block for 50,000 ns
// only continues if no exception

val confirmation = socket.sendToEurope(packet)
// block for 150,000,000 ns
// only continues if no exception
#+end_src

what does 50,000 ns represent?

*** Convert using Norvig's table

** TODO 5 - 4 - Combinators on Futures
** TODO 5 - 5 - Composing Futures
** TODO 5 - 6 - Promises, promises, promises
