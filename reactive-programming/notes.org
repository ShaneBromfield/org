#+title: Reactive programming

* DONE What is reactive programming?
CLOSED: [2013-11-05 mar. 14:15]

Reactive: readily responsive to stimulus

Reacts to:
- events (event-driven)
- load (scalable)
- failures (resilient)
- users (responsive)


Event-driven -> scalable  ->
             -> resilient -> responsive
                          ->


** Traditionally
multiple threads (shared, synchronized state) -> strong coupling, hard to compose

** Now
composed from loosely coupled event-handlers -> events can be handled asynchronously, without blocking

** scalable
an applications is scalable if it can expand according to its usage:
- scale up: make use of parallelism in multi-core system
- scale out: make use of multiple server nodes

important for scalability: minimize shared mutable state
important for scale out: location transparency, resilience


** resilient
recover quickly from failure

failures can be:
- software
- hardware
- connection

it is not an afterthought, it needs to be part of the design from the beginning

** responsive

rich, real-time interaction with its users even under load and in the presence of failures

** fundamental constructions
to get composable event abstractions
- events are first-class
- events are often represented as messages
- handlers of events are also first-class
- complex handlers can be composed from primitive ones


* DONE Recap: Functions and Pattern Matching
CLOSED: [2013-11-05 mar. 14:16]
* DONE Recap: Collections
CLOSED: [2013-11-05 mar. 14:23]
* DONE Functional random generators
CLOSED: [2013-11-06 mer. 13:04]
* TODO Monads

** Def
monad M is a parametric type M[T] with 2 operations, flatMap (bind) and unit that have to satisfy some laws:
- associativity
- left unit
- right unit

In scala, we can see the monad as a trait:

#+begin_src scala
trait M[T] {
  def flatMap[U](f: T => M[U]): M[U]
}

def unit[T](x: T): M[T]
#+end_src

Example of monads:
- List with unit(x) is List(x)
- Set with unit(x) is Set(x)
- Option with unit(x) is Some(x)
- Generator with unit(x) is single(x)
** Monads and map

map can be defined as a combination between flatMap and unit.

#+begin_src scala
m map f == m flatMap (f andThen unit)
#+end_src

** Monad laws
*** Associativity

(m flatMap f) flatMap g == m flatMap ( x => f(x) flatMap g f)

*** Left unit

unit(x) flatMap f == f(x)

*** Right unit
m flatMap unit == m
