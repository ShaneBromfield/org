#+title: Reactive programming

* DONE week 1 [100%]
CLOSED: [2013-11-12 mar. 12:52]
** DONE What is reactive programming?
CLOSED: [2013-11-05 mar. 14:15]

Reactive: readily responsive to stimulus

Reacts to:
- events (event-driven)
- load (scalable)
- failures (resilient)
- users (responsive)


Event-driven -> scalable  ->
             -> resilient -> responsive
                          ->


** Traditionally
multiple threads (shared, synchronized state) -> strong coupling, hard to compose

** Now
composed from loosely coupled event-handlers -> events can be handled asynchronously, without blocking

** scalable
an applications is scalable if it can expand according to its usage:
- scale up: make use of parallelism in multi-core system
- scale out: make use of multiple server nodes

important for scalability: minimize shared mutable state
important for scale out: location transparency, resilience


** resilient
recover quickly from failure

failures can be:
- software
- hardware
- connection

it is not an afterthought, it needs to be part of the design from the beginning

** responsive

rich, real-time interaction with its users even under load and in the presence of failures

** fundamental constructions
to get composable event abstractions
- events are first-class
- events are often represented as messages
- handlers of events are also first-class
- complex handlers can be composed from primitive ones

** DONE Recap: Functions and Pattern Matching
CLOSED: [2013-11-05 mar. 14:16]
** DONE Recap: Collections
CLOSED: [2013-11-05 mar. 14:23]
** DONE Functional random generators
CLOSED: [2013-11-06 mer. 13:04]
** DONE Monads
CLOSED: [2013-11-10 dim. 19:19]

*** Def
monad M is a parametric type M[T] with 2 operations, flatMap (bind) and unit that have to satisfy some laws:
- associativity
- left unit
- right unit

In scala, we can see the monad as a trait:

#+begin_src scala
trait M[T] {
  def flatMap[U](f: T => M[U]): M[U]
}

def unit[T](x: T): M[T]
#+end_src

Example of monads:
- List with unit(x) is List(x)
- Set with unit(x) is Set(x)
- Option with unit(x) is Some(x)
- Generator with unit(x) is single(x)
*** Monads and map

map can be defined as a combination between flatMap and unit.

#+begin_src scala
m map f == m flatMap (f andThen unit)
#+end_src

*** Monad laws
*** Associativity

(m flatMap f) flatMap g == m flatMap ( x => f(x) flatMap g f)

*** Left unit

unit(x) flatMap f == f(x)

*** Right unit
m flatMap unit == m
* IN-PROGRESS week 2 [33%]
** DONE 4 - 1 - Functions and State
CLOSED: [2013-11-12 mar. 13:16]
Without side effect, the concept of time is not important.

Substitution model: programs can be evaluated by rewriting.
As there is no side effect, only reformulation of one's program by replacing each call by it's definition expanding the values.

*** Remarks

Rewriting can be done anywhere in a term.

All rewritings which terminate lead to the same result -> confluence (a.k.a Church-Rosser theorem)

*** Stateful objects
Stateful -> changes over the course of time.

"an object has a state if its behavior is influenced by its history"

*** Implementation of state

In scala, every form of mutable state is constructed from variables.

*** State in objects

objects with state -> objects with variable

Example: Bank Account

#+begin_src scala
 class BankAccount {
  private var balance = 0
  def deposit(amount: Int): Unit = {
    if (amount > 0) balance += amount
  }

  def withdraw(amount: Int): Int = {
    if (0 < amount && amount <= balance) {
      balance -= amount
        balance
    }
  }
}

val acct = new BankAccount
acct deposit 50
acct withdraw 20
acct withdraw 20
acct withdraw 15 // -> Error

#+end_src

*** Statefulness and variables

**** Example 1
#+begin_src scala
def cons[T](hd: T, tl: => Stream[T]) = new Stream[T] {
    def head = hd
    private var tlOpt: Option[Stream[T]] = None
    def tail: T = tlOpt match {
      case Some(x) => x
      case None    => tlOpt = Some(tl); tail
    }
}
#+end_src

Is the result of cons a stateful object?

- No   -> if the tail is pure (without side effect), this is not.

- Yes  -> if the tail is side-effecty, tail will depend on the history so yes

**** Example2

#+begin_src scala
class BankAccountProxy(ba: BankAccount) {
  def deposit(amount: Int): Unit = ba.deposit(amount)
  def withdraw(amount: Int): Int = ba.withdraw(amount)
}
#+end_src

Are instances of BankAccountProxy stateful objects?

Yes -> same call won't result in the same result each time.

