#+title: Reactive programming
resources:
- http://docs.scala-lang.org/overviews/core/futures.html
- http://docs.scala-lang.org/sips/pending/futures-promises.html
- https://github.com/scala/scala/blob/master/src/library/scala/concurrent/Future.scala

* DONE week 1 [100%]
CLOSED: [2013-11-12 mar. 12:52]
** DONE What is reactive programming?
CLOSED: [2013-11-05 mar. 14:15]

Reactive: readily responsive to stimulus

Reacts to:
- events (event-driven)
- load (scalable)
- failures (resilient)
- users (responsive)


Event-driven -> scalable  ->
             -> resilient -> responsive
                          ->


*** Traditionally
multiple threads (shared, synchronized state) -> strong coupling, hard to compose

*** Now
composed from loosely coupled event-handlers -> events can be handled asynchronously, without blocking

*** scalable
an applications is scalable if it can expand according to its usage:
- scale up: make use of parallelism in multi-core system
- scale out: make use of multiple server nodes

important for scalability: minimize shared mutable state
important for scale out: location transparency, resilience


*** resilient
recover quickly from failure

failures can be:
- software
- hardware
- connection

it is not an afterthought, it needs to be part of the design from the beginning

*** responsive

rich, real-time interaction with its users even under load and in the presence of failures

*** fundamental constructions
to get composable event abstractions
- events are first-class
- events are often represented as messages
- handlers of events are also first-class
- complex handlers can be composed from primitive ones

** DONE Recap: Functions and Pattern Matching
CLOSED: [2013-11-05 mar. 14:16]
** DONE Recap: Collections
CLOSED: [2013-11-05 mar. 14:23]
** DONE Functional random generators
CLOSED: [2013-11-06 mer. 13:04]
** DONE Monads
CLOSED: [2013-11-10 dim. 19:19]

*** Def
monad M is a parametric type M[T] with 2 operations, flatMap (bind) and unit that have to satisfy some laws:
- associativity
- left unit
- right unit

In scala, we can see the monad as a trait:

#+begin_src scala
trait M[T] {
  def flatMap[U](f: T => M[U]): M[U]
}

def unit[T](x: T): M[T]
#+end_src

Example of monads:
- List with unit(x) is List(x)
- Set with unit(x) is Set(x)
- Option with unit(x) is Some(x)
- Generator with unit(x) is single(x)
*** Monads and map

map can be defined as a combination between flatMap and unit.

#+begin_src scala
m map f == m flatMap (f andThen unit)
#+end_src

*** Monad laws
*** Associativity

(m flatMap f) flatMap g == m flatMap ( x => f(x) flatMap g f)

*** Left unit

unit(x) flatMap f == f(x)

*** Right unit
m flatMap unit == m
* DONE week 2 [100%]
CLOSED: [2013-11-19 mar. 12:16]
** DONE 4 - 1 - Functions and State
CLOSED: [2013-11-12 mar. 13:16]
Without side effect, the concept of time is not important.

Substitution model: programs can be evaluated by rewriting.
As there is no side effect, only reformulation of one's program by replacing each call by it's definition expanding the values.

*** Remarks

Rewriting can be done anywhere in a term.

All rewritings which terminate lead to the same result -> confluence (a.k.a Church-Rosser theorem)

*** Stateful objects
Stateful -> changes over the course of time.

"an object has a state if its behavior is influenced by its history"

*** Implementation of state

In scala, every form of mutable state is constructed from variables.

*** State in objects

objects with state -> objects with variable

Example: Bank Account

#+begin_src scala
 class BankAccount {
  private var balance = 0
  def deposit(amount: Int): Unit = {
    if (amount > 0) balance += amount
  }

  def withdraw(amount: Int): Int = {
    if (0 < amount && amount <= balance) {
      balance -= amount
        balance
    }
  }
}

val acct = new BankAccount
acct deposit 50
acct withdraw 20
acct withdraw 20
acct withdraw 15 // -> Error

#+end_src

*** Statefulness and variables

**** Example 1
#+begin_src scala
def cons[T](hd: T, tl: => Stream[T]) = new Stream[T] {
    def head = hd
    private var tlOpt: Option[Stream[T]] = None
    def tail: T = tlOpt match {
      case Some(x) => x
      case None    => tlOpt = Some(tl); tail
    }
}
#+end_src

Is the result of cons a stateful object?

- No   -> if the tail is pure (without side effect), this is not.

- Yes  -> if the tail is side-effecty, tail will depend on the history so yes

**** Example2

#+begin_src scala
class BankAccountProxy(ba: BankAccount) {
  def deposit(amount: Int): Unit = ba.deposit(amount)
  def withdraw(amount: Int): Int = ba.withdraw(amount)
}
#+end_src

Are instances of BankAccountProxy stateful objects?

Yes -> same call won't result in the same result each time.

** DONE 4 - 3 - Identity and Change
CLOSED: [2013-11-12 mar. 13:31]
*** Assignment poses new problem
Assignment poses the new problem of deciding whether 2 expressions are the same.

#+begin_src scala
val x = E; val y = E; // -> safe to assume that x and y are the same (val so no assignment).
#+end_src

we could also have written:

#+begin_src scala
val x = E; val y = x;
#+end_src

-> referential transparency

*** Example

#+begin_src scala
val x = new BankAccount
val y = new BankAccount
#+end_src

Are x and y are the same?
No

*** What's "being the same"?

property of "operational equivalence" <-> x and y are operationally equivalent if no possible test can distinguish between them.

How:
- Execute multiple arbitrary definitions on both x and y and check the possible outcomes.
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
f (x, y)
#+end_src

- Then execute the definitions with another sequence S obtained by replacing each x occurrence by y
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
f (x, x)
#+end_src

- Then create another sequence S' by replace x by y in every sequence of S
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
f (y, y)
#+end_src

- if the results are different then the expressions x and y are certainly different

- if all possible pairs of sequences (S, S') produce the same result, then x and y are the same.

*** Example

**** First round

#+begin_src scala
val x = new BankAccount
val y = new BankAccount
x deposit 30  // val res1: Int = 30
y withdraw 20 // -> error
#+end_src

**** Second
#+begin_src scala
val x = new BankAccount
val y = new BankAccount
x deposit 30  // val res1: Int = 30
x withdraw 20 // val res1: Int = 10
#+end_src

**** conclusion

The final result is different then x and y are different

*** Another Example

#+begin_src scala
val x = new BankAccount
val y = x
x deposit 30  // val res1: Int = 30
y withdraw 20 // -> error
#+end_src

Here, using the same experiment, we obtain the same result so x and y are the same.

*** Assignment and substitution model
With previous examples, we can see that the substitution model can no longer be used with assignments.

** DONE 4 - 4 - Loops
CLOSED: [2013-11-12 mar. 14:13]
With assignment, variables are enough to model all imperative programs.
Loop is an unnecessary construct.

Example of the "power" method using the useless native while operation.

*** WHILE

WHILE as a functional function:

#+begin_src scala
def WHILE(condition: => Boolean)(command: => Unit): Unit =
 if (condition) {
   command
   WHILE(condition)(command)
} else ()
#+end_src

Note:
- condition and command must be passed by name so that they're reevaluated in each iteration
- WHILE is tail-recursive so it can operate with a constant stack size

*** REPEAT

Write a function implementing a repeat loop (Repeat the command until the condition is met).

#+begin_src scala
def REPEAT(command: => Unit)(condition: => Boolean): Unit = {
  command
  if (condition) ()
  else REPEAT(command)(condition)
}
#+end_src

** DONE 4 - 5 - Extended Example - Discrete Event Simulation
CLOSED: [2013-11-12 mar. 22:54]
*** Digital circuit
It's composed of:
- wires (transport signals)
- functional components (transform signals)

based components:
- inverter - output is the inverse of its input
- AND      - output is the conjunction of the inputs
- OR       - output is the disjunction of the inputs

Other components are built by combining these base components.

/Note/
Components have a reaction time (delay). Their outputs do not change immediately after a change of their inputs.

*** Diagram - basic

[[./resources/basic-components.png]]

FIXME crop

*** Diagram - combine

[[./resources/combine-basic-in-half-adder.png]]

FIXME crop

*** Gates

#+begin_src scala
def inverter(input: Wire, output: Wire): Unit
def andGate(a1: Wire, a2: Wire, output: Wire): Unit
def orGate(o1: Wire, o2: Wire, output: Wire): Unit
#+end_src

*** Constructing Components

**** Half-adder

Definition:
s = a | b & !(a & b)
c = a & b

#+begin_src scala
def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire): Unit = {
  val d = new Wire
  val e = new Wire

  orGate(a, b, d)
  andGate(a, b, c)
  inverter(c, e)
  andGate(d, e, s)
}
#+end_src

[[./resources/half-adder.png]]

**** Full-adder

composed of 2 full-adders:

#+begin_src scala
def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {
  val s = new Wire
  val c1 = new Wire
  val c2 = new Wire

  halfAdder(b, cin, s, c1)
  halfAdder(a, s, sum, c2)
  orGate(c1, c2, cout)
}
#+end_src

[[./resources/full-adder.png]]


**** Exercise: Mystery function

#+begin_src scala
def f(a: Wire, b: Wire, c: Wire): Unit = {
  val d, e, f, g = Wire
  inverter(a, d)
  inverter(b, e)
  andGate(a, e, f)
  andGate(b, d, g)
  orGate(f, g, c)
}
#+end_src

Question: What logical function does this program describe?

Answer: a != b (xor)

d = !a
e = !b
f = a & !b
g = b & !a
c = f | g = (a & !b) | (b & !a)

|---+---+---+--------+--------+---|
|   | a | b | a & !b | b & !a | c |
|---+---+---+--------+--------+---|
|   | 0 | 0 |      0 |      0 | 0 |
|   | 1 | 0 |      1 |      0 | 1 |
|   | 0 | 1 |      0 |      1 | 1 |
|   | 1 | 1 |      0 |      0 | 0 |
|---+---+---+--------+--------+---|

xor

** DONE 4 - 6 - Discrete Event Simulation_ API and Usage
CLOSED: [2013-11-12 mar. 23:37]
*** Discrete event Simulation
a discrete event simulator performs actions, specified by the user at a given moment.

A action is a function that does not take any parameters and which returns Unit:

#+begin_src scala
type Action = () => Unit
#+end_src

The time is simulated, it has nothing to do with actual time.

*** Simulation trait

A concrete simulation happens inside an object that inherits from the trait Simulation:

#+begin_src scala
trait Simulation {
  // return the current simulated time
  def currentTime: Int = ???
  // registers an action to perform after a certain delay (relative to currentTime)
  def afterDelay(delay: Int)(block: => Unit): Unit = ???
  // performs the simulation until there are no more actions waiting
  def run(): Unit = ???
}
#+end_src

*** Class diagram

Simulation
    |
Gates           Wire, AND, OR, INV
    |
Circuits        HA, ADDER
    |
MySimulation

*** The Wire Class
3 basic operations:

#+begin_src scala
class Wire extends Simulation {
  getSignal: Boolean
  setSignal(sig: Boolean): Unit

  // Attaches the specified procedure to the actions of the wire. All of the attached actions are executed at each change of the transported signal.
  addAction(a: Action): Unit
}
#+end_src


*** Wire implem.

#+begin_src scala
class Wire extends Simulation {
  private var sigVal = false
  private var actions: List[Action] = List()

  getSignal: Boolean = sigVal

  setSignal(sig: Boolean): Unit =
    if (s != sigVal) {
      sigVal = s
      actions foreach(_())                        // use foreach because of the signature returning Unit
    }

  addAction(a: Action): Unit = {
    actions = a :: actions
    a()
  }
}

#+end_src

*** Inverter

installing an action on its input wire.

#+begin_src scala
def inverter(input: Wire, output: Wire) = {
  def invertAction(): Unit = {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) { output setSignal !inputSig }
  }

  input addAction invertAction
}
#+end_src

*** And Gate

#+begin_src scala
def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
  def andAction(): Unit = {
    val in1Sig = in1.getSignal
    val in2Sig = in2.getSignal
    afterDelay(AndGateDelay) { output setSignal (in1Sig & in2Sig) }
  }

  in1 addAction andAction
  in2 addAction andAction
}
#+end_src

*** Or Gate
#+begin_src scala
#+begin_src scala
def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
  def orAction(): Unit = {
    val in1Sig = in1.getSignal
    val in2Sig = in2.getSignal
    afterDelay(OrGateDelay) { output setSignal (in1Sig | in2Sig) }
  }

  in1 addAction orAction
  in2 addAction orAction
}

#+end_src

** DONE 4 - 7 - Discrete Event Simluation_ Implementation and Test
CLOSED: [2013-11-13 mer. 00:04]
*** Simulation trait

#+begin_src scala
trait Simulation {
  type Action = () => Unit
  case class Event(time: Int, action: Action)
  private type Agenda = List[Event]
  private var agenda: Agenda = List()
}
#+end_src

*** Handling time

*** AfterDelay implem.

#+begin_src scala
def afterDelay(delay: Int)(block: => Unit): Unit = {
  val item = Event(currentTime + delay, () => block)
  agenda = insert(agenda, item)
}

private def insert(ag: List[Event], item: Event): List[Event] = ag match {
  case first :: rest if first.time <= item.time =>
    first :: insert(rest, item)
  case _ => item :: ag
}
#+end_src


*** The Event handling Loop

#+begin_src scala
private def loop(): Unit = agenda match {
  case first :: rest =>
    agenda = rest
    curtime = first.time
    first.action()
    loop()
  case Nil =>
}
#+end_src

*** The run method

#+begin_src scala
def run(): Unit = {
  afterDelay(0) {
    println("*** simulation started, time = " + currentTime + " ***")
  }
  loop()
}
#+end_src

*** Probes

A way to examine the changes of the signals on the wires:

#+begin_src scala
def probe(name: String, Wire: Wire): Unit = {
  def probeAction(): Unit = {
    println(s"$name $currentTime value = ${wire.getSignal}")
  }
  wire addAction probeAction
}
#+end_src

*** Defining Technology-Dependent Parameters

#+begin_src scala
trait Parameters {
  def InverterDelay = 2
  def AndGateDelay = 3
  def OrGateDelay = 5
}
#+end_src

We can add another trait to the MySimulation:
#+begin_src scala
object MySimulation extends Circuits with Parameters
#+end_src

*** Circuits

#+begin_src scala
class Circuits extends {
  def half-adder...
  def full-adder...
}
#+end_src
* DONE week 3 [100%]
CLOSED: [2013-11-19 mar. 18:32]
** DONE 5 - 1 - Monads and Effects
CLOSED: [2013-11-19 mar. 09:53]
|--------------+-----------+---------------|
|              | One       | Many          |
|--------------+-----------+---------------|
| Synchronous  | Try[T]    | Iterable[T]   |
| Asynchronous | Future[T] | Observable[T] |
|--------------+-----------+---------------|

*** Simple adventure game

#+begin_src scala
trait Adventure {
  def collectCoins(): List[Coin]
  def buyTreasure(coins: List[Coin]): Treasure
}
#+end_src

No as simple as we may think since me need to deal with failure.
This does not appear when orchestrating code

*** Actions may fail

We need to add the failure.

If we look at implementation details in collectCoins and buyTreasure, we see the unhappy path.

*** Sequential composition of actions that may fail

*** Expose possibility of failure in the types, honestly

From: T => S
To: T => Try[S]

*** Making failure evident in the type

Using:
#+begin_src scala
import scala.util.{Try, Success, Failure}

abstract class Try[T]
case class Success[T](elem: T) extends Try[T]
case class Failure[T](t: Throwable) extends Try[Nothing]
#+end_src

Now the trait becomes:

#+begin_src scala
trait Adventure {
  def collectCoins(): Try[List[Coin]]
  def buyTreasure(coins: List[Coin]): Try[Treasure]
}
#+end_src

*** Dealing with failure explicitely

Code becomes uglier but it reflects the reality we ever meant:
#+begin_src scala
val adventure = Adventure()

val coins: Try[List[Coin]] = adventure.collectCoins()

val treasure: Try[Treasure] = coins match {
  case Success(cs)        => adventure.buyTreasure(cs)
  case failure@Failure(t) => failure
}
#+end_src

*** HOF to manipulate Try[T]

#+begin_src scala
def flatMap[S](f: T => Try[S]): Try[S]
def flatten[U <: Try[T]]: Try[U]
def map[S](f: T => S): Try[T]
def filter(p: T => Boolean): Try[T]
def recoverWith(f: PartialFunction[Throwable, Try[T]]): Try[T]
#+end_src

*** Monads guide you through the happy path

Try[T], a monad (has flatMap + previous rules) that handles exceptions

Effects are visible in the type.


*** Noise reduction

1. Using flatMap
#+begin_src scala
val adventure = Adventure()

val treasure: Try[Treasure] =
  adventure.collectCoins().flatMap(coins => adventure.buyTreasure(coins))
#+end_src

2. Using for-comprehension (flatMap inside :D)
#+begin_src scala
val adventure = Adventure()

val treasure: Try[Treasure] =
  for(coins <- adventure.collectCoins;
      treasure <- adventure.buyTreasure(coins)) yield treasure
#+end_src

*** HOF to manipulate Try[T]

Object companion of Try (called at construction if memory serves me well):

#+begin_src scala
object Try {
  def apply[T](r: => T): Try[T] = { // r call by name to delay the execution
    try { Success(r) }
    catch { case t => Failure(t) }
  }
}
#+end_src

Map implementation of Try:

#+begin_src scala
def map[S](f: T => S): Try[S] = this match {
  case Success(value)     => Try(f(value))
  case failure@Failure(t) => failure
}
#+end_src

Try helps in materializing the exceptions!

*** Quiz
FlatMap implementation:

#+begin_src scala
def flatMap[S](f: T => Try[S]): Try[S] = this match {
  case Success(value)     => try { f(value) } catch { case t => Failure(t) }
  case failure@Failure(t) => failure
}
#+end_src

** DONE 5 - 3 - Latency as an Effect
CLOSED: [2013-11-19 mar. 13:22]

*** A simple adventure game... is very similar to a simple network stack
#+begin_src scala
trait Socket {
  def readFromMemory(): Array[Byte]
  def sendToEurope(packet: Array[Byte]): Array[Byte]
}

val socket = new Socket()
val packet = socket.readFromMemory()
val confirmation = socket.sendToEurope(packet)
#+end_src

Side-effects apparent?

*** Timings for various operations on a typical PC on human scale
Peter Norvig's table

|-------------------------------------+------------|
| Instructions                        |  Time (ns) |
|-------------------------------------+------------|
| execute typical instruction         | 1000000000 |
| fetch from L1 cache memory          |        0.5 |
| branch misprediction                |          5 |
| fetch from L2 cache memory          |          7 |
| mutex lock/unlock                   |         25 |
| fetch from main memory              |        100 |
| send 2k bytes over 1Gbps network    |      20000 |
| read 1Mb sequentially from memory   |     250000 |
| fetch from new disk location (seek) |    8000000 |
| read 1Mb sequentially from disk     |   20000000 |
| send packet US to Europe and back   |  150000000 |
|-------------------------------------+------------|

http://norvig.com/21-days.html#answers
*** Sequential composition of actions that take time
#+begin_src scala
val socket = new Socket()
val packet = socket.readFromMemory()
// block for 50,000 ns
// only continues if no exception

val confirmation = socket.sendToEurope(packet)
// block for 150,000,000 ns
// only continues if no exception
#+end_src

but what does 50,000 ns represent in human term?

*** Convert using Norvig's table

Let's convert those ns into second.
This is not the reality!

 |-------------------------------------+------------|
 | Instructions                        | Time       |
 |-------------------------------------+------------|
 | execute typical instruction         | 1          |
 | fetch from L1 cache memory          | 0.5s       |
 | branch misprediction                | 5s         |
 | fetch from L2 cache memory          | 7s         |
 | mutex lock/unlock                   | 0.5m       |
 | fetch from main memory              | 1.5m       |
 | send 2k bytes over 1Gbps network    | 5.5h       |
 | read 1Mb sequentially from memory   | 3d         |
 | fetch from new disk location (seek) | 13w        |
 | read 1Mb sequentially from disk     | 6.5 months |
 | send packet US to Europe and back   | 5y         |
 |-------------------------------------+------------|

#+begin_src scala
val socket = new Socket()
val packet = socket.readFromMemory()
// block for 3 days
// only continues if no exception

val confirmation = socket.sendToEurope(packet)
// block for 5 years
// only continues if no exception
#+end_src

This is huge!


*** Monads guide you through the happy path

Future[T] a monad that handles exception and latency

*** Futures asynchronously notify consumers

Futures are computation that completes on the future.

#+begin_src scala
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global

trait Future[T] {
  def onComplete(callback: Try[T] => Unit)
    (implicit executor: ExecutionContext): Unit
}
#+end_src

NB: The execution context will remain implicit as this is not necessary to understand futures.

*** Futures alternative designs

#+begin_src scala
trait Future[T] {
  def onComplete(success: T => Unit, failed: Throwable => Unit)
    (implicit executor: ExecutionContext): Unit

  def onComplete(callback: Observer[T]): Unit
}

trait Observer[T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
}
#+end_src

*** Futures asynchronously notify consumers

#+begin_src scala
trait Socket {
  def readFromMemory(): Future[Array[Byte]]
  def sendToEurope(packet: Array[Byte]): Future[Array[Byte]]
}
#+end_src

If you know the computation will take a long time, always make your method return a future.

*** Send packets using futures I

Impact on the code obviously.

#+begin_src scala
val socket = Socket()

val packet: Future[Array[Byte]] = socket.readFromMemory()

val confirmation: Future[Array[Byte]] =
  packet onComplete {
    case Success(p) => socket.sendToEurope(p)
    case Failure(t) => ...
}
#+end_src
This does not work

*** Send packets using futures II

Impact on the code obviously.

#+begin_src scala
val socket = Socket()

val packet: Future[Array[Byte]] = socket.readFromMemory()

packet onComplete {
  case Success(p) =>
    val confirmation: Future[Array[Byte]] = socket.sendToEurope(p)
  case Failure(t) => ...
}
#+end_src

This does work but this can lead to spaghetti code!
CARNAGE!

Isn't there a better way?

*** Creating Futures

Starts an async computation and returns a future object to which you can suscribe to be notified when the future completes

Companion object for Future:
#+begin_src scala
Object Future {
  def apply(body: => T)
   (implicit context: ExecutionContext): Future[T]
}
#+end_src

*** Creating Futures
#+begin_src scala
import scala.concurrent.ExecutionContext.Implicits.global
import akka.serializer._

val memory = Queue[EMailMessage](
  EMailMessage(from = "Erik", to = "Roland"),
  EMailMessage(from = "Martin", to = "Erik"),
  EMailMessage(from = "Roland", to = "Martin"),
  ...

def readFromMemory(): Future[Array[Byte]] = Future {
  val email = queue.dequeue()
  val serializer = serialization.findSerializerFor(email)
  serializer.toBinary(email)
}
#+end_src

*** Quiz

#+begin_src scala
import scala.concurrent.ExecutionContext.Implicits.global

val packet: Future[Array[Byte]] = socket.readFromMemory()

packet.onSuccess {
  case bs => socket.sendToEurope(p)
}

packet.onSuccess {
  case bs => socket.sendToEurope(p)
}
#+end_src

How many messages remains in the e-mail queue? 3, 2, 1, or 0
-> 2

** DONE 5 - 4 - Combinators on Futures
CLOSED: [2013-11-19 mar. 14:03]

*** Futures recap
Future is a monad (flatMap in implem.)

#+begin_src scala
trait Awaitable[T] extends AnyRef {
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {
  def filter(p: T => Boolean): Future[T]
  def flatMap[S](f: T => Future[S]): Future[U]
  def map[S](f: T => S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}

object Future {
  def apply[T](body: => T): Future[T]
}
#+end_src

*** Sending packets using features

THE MESS:
#+begin_src scala
val socket = Socket()

val packet: Future[Array[Byte]] = socket.readFromMemory()

packet onComplete {
  case Success(p) =>
    val confirmation: Future[Array[Byte]] = socket.sendToEurope(p)
  case Failure(t) => ...
}
#+end_src

*** FlatMap to the rescue

#+begin_src scala
val socket = Socket()

val packet: Future[Array[Byte]] = socket.readFromMemory()

val confirmation: Future[Array[Byte]] = packet.flatMap(p => socket.sendToEurope(p))
#+end_src

In scala, flatMap is the hero of every monad.

*** Sending packets using futures under the covers

#+begin_src scala
import scala.concurrent.ExecutionContext.Implicits.global
import scala.imaginary.Http._

object Http {
  def apply(url: URL, req: Request): Future[Response] =
   // runs the http request asynchronously
}

def sendToEurope(packet: Array[Byte]): Future[Array[Byte]] =
  Http.url(URL("mail.server.eu"), Request(packet))
    .filter(response => response.isOK)
    .map(response => response.toByteArray)
#+end_src

Code seems nice but can still break at some point.

*** Sending packets using futures robustly (?)

#+begin_src scala
def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =
  Http.url(url, Request(packet))
    .filter(response => response.isOK)
    .map(response => response.toByteArray)

def sendToAndBackup(packet: Array[Byte]): Future[(Array[Byte], Array[Byte])] = {
  val europeConfirm = sendTo(mailServer.europe, packet)
  val usaConfirm = sendTo(mailServer.usa, packet)
  europeConfirm.zip(usaConfirm)
}
#+end_src

Not more robust.

*** Send packets using futures robustly

- recover: If future has failed, you can return the throwable containing the error.
#+begin_src scala
def recover(f: PartialFunction[Throwable, T]): Future[T]
#+end_src

- recoverWith: If the future fails, try the second future as fallback.
#+begin_src scala
def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
#+end_src

*** Send packets using futures robustly

n#+begin_src scala
def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =
  Http.url(url, Request(packet))
    .filter(response => response.isOK)
    .map(response => response.toByteArray)

def sendToSafe(packet: Array[Byte]): Future[(Array[Byte], Array[Byte])] =
  sendTo(mailServer.europe, packet) recoverWith {
    case europeError => sendTo(mailServer.usa, packet) recover {
      case usaError => usaError.getMessage.toByteArray
    }
  }

#+end_src

Not good yet, because we receive the confirmation from usa even for europe.

*** Better recovery with less matching

#+begin_src scala
def sendToSafe(packet: Array[Byte]): Future[(Array[Byte], Array[Byte])] =
  sendTo(mailServer.europe, packet) fallbackTo {
    sendTo(mailServer.usa, packet)
  } recover {
      case europeError => europeError.getMessage.toByteArray
    }
  }

def fallbackTo(that: => Future[T]): Future[T] =
  //... if 'this' future fails take the successful result of 'that' future
  //... if 'that' future fails too, take the error of 'this' future
#+end_src


*** Fallback implementation

#+begin_src scala
def sendToSafe(packet: Array[Byte]): Future[(Array[Byte], Array[Byte])] =
  sendTo(mailServer.europe, packet) fallbackTo {
    sendTo(mailServer.usa, packet)
  } recover {
      case europeError => europeError.getMessage.toByteArray
    }
  }

def fallbackTo(that: => Future[T]): Future[T] =
  this recoverWith {
    case _ => that recoverWith { case _ => this }
  }

#+end_src

*** Quiz

#+begin_src scala
object Try {
  def apply(f: Future[T]): Future[Try[T]] = ...
}
#+end_src

What's the correct implementation?

#+begin_src scala
object Try {
  def apply(f: Future[T]): Future[Try[T]] =
    f map { x => Success(s) } recover { case t => Failure(t) }
}
#+end_src

*** Asynchronous where possible, blocking where necessary

#+begin_src scala
trait Awaitable[T] extends AnyRef {
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}
#+end_src

Beware with this trait, we can get out of the monad world => DANGEROUS

Never block if unnecessary

*** Asynchronous where possible, blocking where necessary

#+begin_src scala
val socket = Socket()

val packet: Future[Array[Byte]] = socket.readFromMemory()

val confirmation: Future[Array[Byte]] =
  packet.flatMap(socket.sendToSafe(_))

val c = Await.result(confirmation, 2 seconds)
println(c.toText)

#+end_src

*** Duration

#+begin_src scala
import scala.language.postfixOps

object Duration {
  def apply(length: Long, unit: TimeUnit): Duration
}

val fiveYears = 1826 minutes
#+end_src

** DONE 5 - 5 - Composing Futures
CLOSED: [2013-11-19 mar. 14:44]
*** FlatMap
*** Comprehensions
#+begin_src scala
val socket = Socket()
val confirmation: Future[Array[Byte]] = for {
  packet <- socket.readFromMemory()
  confirmation <- socket.sendToSafe(packet)
} yield confirmation
#+end_src
*** Retrying to send

#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] =
  // retry successfully completing block at most noTimes
  // and give up after that
#+end_src

*** Retrying to send implem.
#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] =
  if (noTimes == 0)
    Future.failed(new Exception("sorry"))
  else
    block fallbackTo retry(noTimes - 1)(block)
#+end_src

Try to avoid recursion and use a more higher level approach (fold)

*** Folding lists

"Northern wind comes from the North" (Richard Bird)

Right comes from the right
#+BEGIN_QUOTE
List(a, b, c).foldRight(e)(f) <=> f(a, f(b, f(c, e)))
#+END_QUOTE

Left comes from the left
#+BEGIN_QUOTE
List(a, b, c).foldLeft(e)(f) <=> f(f(f(e, a), b), c)
#+END_QUOTE

*** Retrying to send implem. using foldLeft pattern
#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] = {
  val ns: Iterator[Int] = (1 to noTimes).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ => () => block)
  val failed = Future.failed(new Exception("sorry"))

  attempts.foldLeft(failed)((a, block) => a recoverWith { block() })
}
#+end_src

*** Retrying to send implem. using foldRight pattern

#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] = {
  val ns: Iterator[Int] = (1 to noTimes).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ => () => block)
  val failed = Future.failed(new Exception("sorry"))

  attempts.foldRight(() => failed)((block, a) => block() fallbackTo { a() })
}
#+end_src

This is COMPLICATED code => not good

We need to write baby code.
Needs to be intuitive

*** Making effects implicit

We want to render the effects implicit here:

From:
T => Future[S]
to:
T => Try[S]
or even:
T => S

*** Async await magic
#+begin_src scala
import scala.async.Async._

def async[T](body: => T)
  (implicit context: ExecutionContext): Future[T]

def await[T](future: Future[T]): T
#+end_src

This way, we can use an async code which contains a more natural and regular code to read which is Asynchronous.

#+begin_src scala
async {
  // "normal" code
}
#+end_src

*** Async, the small print

Some illegal uses:
- await requires a directly-enclosing async (await must not be used inside a closure nested within an async block, or inside a nested object, trait or class)
- await must not be used inside an expression passed as argument to a by-name parameter
- not be used inside a Boolean short-circuit argument
- return expressions are illegal inside an async block
- Await should not be used under a try/catch

*** Retrying to send using await

#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] = async {
  var i = 0
  var result: Try[T] = Failure(new Exception("sorry"))
  while (i < noTimes && result.isFailure) {
    result = await { Try(block) }
    i += 1
  }
  result.get
}
#+end_src

Erik Mejer: "Sometimes, using an imperative style is the more natural way"...

*** Reimplementing filter using await

#+begin_src scala
def filter(p: T => Boolean): Future[T] = async {
  val x = await { this }
  if (!p(x)) throw new NoSuchElementException()
  else x
}
#+end_src

*** Quiz

Recall:

#+begin_src scala
def async[T](body: => T)
  (implicit context: ExecutionContext): Future[T]

def await[T](future: Future[T]): T
#+end_src

flatMap using async/await
#+begin_src scala
def flatMap[S](f: T => Future[S]): Future[S] = ...
#+end_src

Answer:

#+begin_src scala
def flatMap[S](f: T => Future[S]): Future[S] = async {
  await {
    f( await { this } )
  }
}
#+end_src

Checking the type:
await { this }: Future[T] => T
f             : T => Future[S]
await         : S
async         : Future[S]

*** Reimplementing filter on Future[T]

#+begin_src scala
def filter(pred: T => Boolean): Future = {
  val p = Promise[T]()

  this onComplete {
    case Failure(e) => p.failure(e)
    case Success(x) => if (!pred(e)) p.failure(new NoSuchElementException())
                       else p.success(x)
  }
  p.future
}
#+end_src

** DONE 5 - 6 - Promises, promises, promises
CLOSED: [2013-11-19 mar. 18:32]
*** Promises

A Promise contains a Future.

When creating the promise, you can take the future out of the promise.
And the future will be notified (its callback will be called) whenever you call complete on the promise!!!

#+begin_src scala
trait Promise[T] {
  ...
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean
  ...
}

trait Future[T] {
  ...
  def onCompleted(f: Try[T] => Unit): Unit
  ...
}
#+end_src

Note:
- Think of the promise as a mailbox.

- A future is idempotent
- you can call complete on promise only once (otherwise, "complete" will throw)
- you can only complete a promise once
- "tryComplete" will return true once and false the other time

*** Racing
#+begin_src scala
import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {
  val p = Promise[T]()
  left onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }
  p.future
}
#+end_src

The first future that completes will run the race by setting the value of the future p.

*** Simpler helper methods

#+begin_src scala
def success(value: T): Unit = this.complete(Success(value))

def failure(t: Throwable): Unit = this.complete(Failure(t))
#+end_src

*** Reimplementing filter on Future[T]

#+begin_src scala
def filter(pred: T => Boolean): Future = {
  val p = Promise[T]()

  this onComplete {
    case Failure(e) => p.failure(e)
    case Success(x) => if (!pred(e)) p.failure(new NoSuchElementException())
                       else p.success(x)
  }
  p.future
}
#+end_src

*** Reimplementing zip using Promises

#+begin_src scala
def zip[S, R](that: Future[S], f: (T, S) => R): Future[R] = {
  val p = Promise[R]()

  this onComplete {
    case Failure(e) => p.failure(e)
    case Success(x) => that onComplete {
        case Failure(e) => p.failure(e)
        case Success(y) => p.success(f(x,y))
      }
  }
  p.future
}
#+end_src

Imbrication is not that beautiful.

*** Reimplementing zip with await

#+begin_src scala
def zip[S, R](p: Future[S], f: (T, S) => R): Future[R] = async {
  f(await { this }, await { that })
}
#+end_src

Using async/await permits to concentrate on the essence of what we want to implement.

*** Implement sequence with Promise
#+begin_src scala
def sequence[T](fs: List[Future[T]]): Future[List[T]] = {
  val successful = Promise[List[T]]()
  fs.foldRight(successful.future) {
    (f, acc) => for { x <- f; xs <- acc } yield x :: xs
  }
}
#+end_src

This is hairy!

*** Implement sequence with await

#+begin_src scala
def sequence[T](fs: List[Future[T]]): Future[List[T]] = async {
  var _fs = fs
  val r = ListBuffer[T]()

  while(_fs != Nil) {
    r += await { _fs.head }
    _fs = _fs.tail
  }
  f.result
}
#+end_src

this is "mapM".
