#+TITLE: Clojure
#+STARTUP: indent
#+OPTIONS: toc:nil
#+DESCRIPTION: Presenting clojure

* Who am I?

#+begin_src clojure
{:github  "@ardumont"
 :twitter "@ardumont"
 :work    "developer/devops"}
#+end_src

* TL; DR

- [[Http://clojure.org/functional_programming][Functional programming]] language

- Runs on the JVM

- [[http://en.wikipedia.org/wiki/Lisp_%28programming_language%29][Dialect of LISP]]!

* Java vs. Clojure

** Java

#+BEGIN_SRC java
/**
 * Some records list conversion.
 */
public List<ConvertedRecord> convertRecords(final List<Record> records) {
  final List<ConvertedRecord> convertedRecords = Lists.<ConvertedRecord>newArrayList();
  for (final Record record : records) {
    if("some-value-to-filter".equals(record.getName())) {
      convertedRecords.add(convert(record));
    }
  }
  return convertedRecords;
}
#+END_SRC

** Clojure
#+begin_src clojure
(defn convert-records [records] "Some records list conversion."
  (map convert (filter (fn [e] (= (get-name e) "some-value-to-filter")) records)))
#+end_src

* Purpose?

- General-purpose language

- Ease of development in mind

- incidental complexity is not work but waste.

- native tools to help you develop your application
  - concurrency

  - feedback (REPL)

  - idiomatic immutability

  - focus on the problem at hand

* How?

** [[http://clojure.org/functional_programming][Functional programming]]

- Reasoning

- Data are de facto immutable

- Functions are first class citizen

- Higher Order Function

  - inputs -> output

  - manipulate other functions

  - can return functions

- lazyness

  Only basic constructions are lazy (map, filter, iterate, etc...)

** JVM

- Access to native platform primitives

- Interoperability

- Generates native byte code

** LISP

- Exists since the programming language's dawn of time (1958).

- Homoiconic: code is data and data is code

- no syntax

** Dynamic

- Compilation transparent

- Interact via REPL

** Homoiconic

- data <=> code

- Native extensions beside core

- Macros

** Immutability

** Persistent data structure

- Simple concurrent programming api

- Software Transaction Memory system

* Limits

- No type

- Not pure -> side effects

- Not fully lazy

- No tail recursion

- For performance reasons, we need to help the compiler to optimize with type hints
